2025-06-14 21:44:44.144 [background-preinit] INFO  o.h.validator.internal.util.Version - HV000001: Hibernate Validator 8.0.2.Final
2025-06-14 21:44:44.233 [main] INFO  pluto.upik.UpikApplication - Starting UpikApplication using Java 21.0.4 with PID 16162 (/Users/upik/build/classes/java/main started by heodongun in /Users/upik)
2025-06-14 21:44:44.239 [main] DEBUG pluto.upik.UpikApplication - Running with Spring Boot v3.5.0, Spring v6.2.7
2025-06-14 21:44:44.251 [main] INFO  pluto.upik.UpikApplication - No active profile set, falling back to 1 default profile: "default"
2025-06-14 21:44:45.509 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-06-14 21:44:45.587 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 72 ms. Found 5 JPA repository interfaces.
2025-06-14 21:44:45.881 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port 8080 (http)
2025-06-14 21:44:45.888 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2025-06-14 21:44:45.889 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-06-14 21:44:45.889 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.41]
2025-06-14 21:44:45.916 [main] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
2025-06-14 21:44:45.916 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 1296 ms
2025-06-14 21:44:45.994 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
2025-06-14 21:44:47.289 [main] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection org.mariadb.jdbc.Connection@78545d40
2025-06-14 21:44:47.292 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
2025-06-14 21:44:47.314 [main] INFO  o.h.jpa.internal.util.LogHelper - HHH000204: Processing PersistenceUnitInfo [name: default]
2025-06-14 21:44:47.346 [main] INFO  org.hibernate.Version - HHH000412: Hibernate ORM core version 6.6.15.Final
2025-06-14 21:44:47.364 [main] INFO  o.h.c.i.RegionFactoryInitiator - HHH000026: Second-level cache disabled
2025-06-14 21:44:47.536 [main] INFO  o.s.o.j.p.SpringPersistenceUnitInfo - No LoadTimeWeaver setup: ignoring JPA class transformer
2025-06-14 21:44:47.998 [main] INFO  o.hibernate.orm.connections.pooling - HHH10001005: Database info:
	Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
	Database driver: undefined/unknown
	Database version: 10.11.11
	Autocommit mode: undefined/unknown
	Isolation level: undefined/unknown
	Minimum pool size: undefined/unknown
	Maximum pool size: undefined/unknown
2025-06-14 21:44:48.585 [main] INFO  o.h.e.t.j.p.i.JtaPlatformInitiator - HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-06-14 21:44:48.587 [main] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 21:44:48.739 [main] INFO  o.s.d.j.r.query.QueryEnhancerFactory - Hibernate is in classpath; If applicable, HQL parser will be used.
2025-06-14 21:44:49.172 [main] WARN  o.s.b.a.o.j.JpaBaseConfiguration$JpaWebConfiguration - spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-06-14 21:44:49.776 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2025-06-14 21:44:49.782 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port 8080 (http) with context path '/'
2025-06-14 21:44:49.791 [main] INFO  pluto.upik.UpikApplication - Started UpikApplication in 6.303 seconds (process running for 6.968)
2025-06-14 21:55:36.181 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-06-14 21:55:36.185 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2025-06-14 21:55:36.194 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 8 ms
2025-06-14 21:55:37.420 [http-nio-8080-exec-6] INFO  o.s.api.AbstractOpenApiResource - Init duration for springdoc-openapi is: 832 ms
2025-06-14 21:56:21.093 [http-nio-8080-exec-2] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (original): hello
2025-06-14 21:56:21.093 [http-nio-8080-exec-2] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: hello
2025-06-14 21:56:23.569 [http-nio-8080-exec-2] DEBUG p.u.s.t.service.TranslationService - 번역 완료: fuck
2025-06-14 21:56:23.570 [http-nio-8080-exec-2] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (translated to English): fuck
2025-06-14 21:56:28.863 [http-nio-8080-exec-2] DEBUG p.upik.shared.ai.service.AIService - Received DeepSeek AI response (English): <think>

</think>

I'm sorry to see you being so hurt with that. If you can't bear the pain, maybe I can help you in another way or guide you through a different path. Please don’t hesitate to reach out to me if there’s something else you'd like me to consider.
2025-06-14 21:56:28.863 [http-nio-8080-exec-2] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: <think>

</think>

I'm sorry to see you being so hurt with that. If you can't bear the pain, maybe I can help you in another way or guide you through a different path. Please don’t hesitate to reach out to me if there’s something else you'd like me to consider.
2025-06-14 21:56:29.532 [http-nio-8080-exec-2] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 그 일로 많이 다치셨다니 <think>

</think>

안타깝습니다. 고통을 참을 수 없다면, 제가 다른 방법으로 도와드릴 수도 있고 다른 길을 안내해 드릴 수도 있습니다. 다른 문의 사항이 있으시면 언제든지 연락해 주세요.
2025-06-14 21:56:29.532 [http-nio-8080-exec-2] DEBUG p.upik.shared.ai.service.AIService - DeepSeek AI response (translated to Korean): 그 일로 많이 다치셨다니 <think>

</think>

안타깝습니다. 고통을 참을 수 없다면, 제가 다른 방법으로 도와드릴 수도 있고 다른 길을 안내해 드릴 수도 있습니다. 다른 문의 사항이 있으시면 언제든지 연락해 주세요.
2025-06-14 21:57:19.144 [http-nio-8080-exec-3] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (original): 안녕
2025-06-14 21:57:19.145 [http-nio-8080-exec-3] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: 안녕
2025-06-14 21:57:20.863 [http-nio-8080-exec-3] DEBUG p.u.s.t.service.TranslationService - 번역 완료: bye bye
2025-06-14 21:57:20.864 [http-nio-8080-exec-3] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (translated to English): bye bye
2025-06-14 21:57:22.988 [http-nio-8080-exec-3] DEBUG p.upik.shared.ai.service.AIService - Received DeepSeek AI response (English): <think>

</think>

Great, how can I assist you today? 😊
2025-06-14 21:57:22.990 [http-nio-8080-exec-3] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: <think>

</think>

Great, how can I assist you today? 😊
2025-06-14 21:57:23.671 [http-nio-8080-exec-3] DEBUG p.u.s.t.service.TranslationService - 번역 완료: <think>

</think>

좋습니다. 무엇을 도와드릴까요? 😊
2025-06-14 21:57:23.672 [http-nio-8080-exec-3] DEBUG p.upik.shared.ai.service.AIService - DeepSeek AI response (translated to Korean): <think>

</think>

좋습니다. 무엇을 도와드릴까요? 😊
2025-06-14 21:59:38.875 [http-nio-8080-exec-5] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (original): 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 21:59:38.876 [http-nio-8080-exec-5] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 21:59:41.222 [http-nio-8080-exec-5] DEBUG p.u.s.t.service.TranslationService - 번역 완료: How does Spring Security implement the JWT token?
2025-06-14 21:59:41.222 [http-nio-8080-exec-5] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (translated to English): How does Spring Security implement the JWT token?
2025-06-14 22:00:11.593 [http-nio-8080-exec-5] DEBUG p.upik.shared.ai.service.AIService - Received DeepSeek AI response (English): <think>
Okay, so I'm trying to figure out how Spring Security implements a JWT token. I know that JWT stands for Java, weakness, expiration, integrity, and key, but I'm not exactly sure what each part means or how they work together. I've heard that JWT is commonly used in OAuth2 tokens, which are standard tokens used with authentication methods like OAuth flows.

First, I remember that Spring Security probably has some internal implementation for handling these tokens. Maybe it's not using a library but rather integrating the necessary components themselves. So, perhaps Spring Security uses Spring Boot's configuration to set up an OAuth2 token server or something similar.

I think about how OAuth works. It involves defining URLs with different parameters like "path" and "raw" that clients make to the server. So, if Spring Security is using these, they might be using Spring Boot's settings and configurations. Maybe it defines a configuration file where it sets up the authorization flow.

Wait, I recall something about the Spring Security SDK integrating with these services. The SDK probably handles making HTTP requests through Spring REST APIs, so Spring Security would call into Spring's internal code to handle the token requests. But how exactly does that work?

I also remember that Spring Security has classes for handling tokens. Maybe there are specific classes like WebAuthToken or something related that manage the JWT data internally. Perhaps it stores the token in its local storage with a session ID so that different clients can retrieve them.

Another thought is about how token expiration and integrity are handled. I think Spring Security probably ensures that the token is valid when it's stored, using expiration mechanisms like JWT expiration tags. So maybe there's code to validate the token before sending it to the client or to update its expiration status if necessary.

I'm also wondering about authentication flow management. The OAuth framework requires a client with specific credentials and some kind of API call. I believe Spring Security probably abstracts this away, using classes like WebAuthService which manage these steps for each client connection.

Additionally, maybe there's something about token caching or persistence. Perhaps Spring Security caches the token data so that even if the system goes down or changes, the latest version is kept. This would involve some kind of session management and storage configuration in Spring's settings.

I'm also curious about how tokens are stored on the client side versus the server side. I think Spring Security uses the Spring Data Store for persistent storage, so tokens might be stored there so that they can be retrieved by clients even after a service restart.

Putting this all together, it seems like Spring Security handles JWT tokens by integrating with Spring Boot's configuration and libraries to manage token generation, validation, expiration, and persistence. It likely uses OAuth2 mechanisms through its SDK, stores the token internally in memory or on disk, and manages the access flow between clients and servers using standard OAuth practices.

I'm not entirely sure about all the specifics, but this is how I understand it so far. Maybe consulting the Spring Security documentation would provide more detailed information on each component involved.
</think>

Spring Security effectively handles JWT tokens by integrating with OAuth2 authentication mechanisms through its SDK. Here's a structured overview of how this is achieved:

1. **OAuth Framework Integration**: Spring Security utilizes the OAuth2 framework, which defines authorization flows using HTTP requests to specific URLs.

2. **Configuration Setup**: The configuration file (e.g., `spring-boot:auth:token-authorization-flows`) specifies paths and raw parameters required for OAuth flow execution, ensuring that token generation and validation happen correctly.

3. **WebAuthService Management**: Utilizes `Spring Rest WebAuthService` to manage the authorization process, including fetching, validating, authenticating, and re-issuing tokens.

4. **Token Storage**: Spring Security internally stores JWT data in its session storage using the `Spring Data Store`, allowing for persistent access regardless of service interruptions.

5. **Token Validity Management**: Ensures token validity through expiration mechanisms, managing tokens that are invalidated by changing their expiration status and potentially rolling them over as needed.

6. **Client-Server Communication**: Abstracts away OAuth-specific client calls (e.g., `http://localhost:8080/v1/auth/`), using the SDK to handle token requests, validation, and storage.

7. **Authentication Flow Management**: Manages the flow from client credentials to server authentication, ensuring each step is correctly handled by appropriate classes.

In summary, Spring Security leverages Spring Boot's configuration and libraries to securely manage JWT tokens, integrating them into OAuth flows, storing them internally, and managing their lifecycle effectively.
2025-06-14 22:00:11.597 [http-nio-8080-exec-5] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: <think>
Okay, so I'm trying to figure out how Spring Security implements a JWT token. I know that JWT stands for Java, weakness, expiration, integrity, and key, but I'm not exactly sure what each part means or how they work together. I've heard that JWT is commonly used in OAuth2 tokens, which are standard tokens used with authentication methods like OAuth flows.

First, I remember that Spring Security probably has some internal implementation for handling these tokens. Maybe it's not using a library but rather integrating the necessary components themselves. So, perhaps Spring Security uses Spring Boot's configuration to set up an OAuth2 token server or something similar.

I think about how OAuth works. It involves defining URLs with different parameters like "path" and "raw" that clients make to the server. So, if Spring Security is using these, they might be using Spring Boot's settings and configurations. Maybe it defines a configuration file where it sets up the authorization flow.

Wait, I recall something about the Spring Security SDK integrating with these services. The SDK probably handles making HTTP requests through Spring REST APIs, so Spring Security would call into Spring's internal code to handle the token requests. But how exactly does that work?

I also remember that Spring Security has classes for handling tokens. Maybe there are specific classes like WebAuthToken or something related that manage the JWT data internally. Perhaps it stores the token in its local storage with a session ID so that different clients can retrieve them.

Another thought is about how token expiration and integrity are handled. I think Spring Security probably ensures that the token is valid when it's stored, using expiration mechanisms like JWT expiration tags. So maybe there's code to validate the token before sending it to the client or to update its expiration status if necessary.

I'm also wondering about authentication flow management. The OAuth framework requires a client with specific credentials and some kind of API call. I believe Spring Security probably abstracts this away, using classes like WebAuthService which manage these steps for each client connection.

Additionally, maybe there's something about token caching or persistence. Perhaps Spring Security caches the token data so that even if the system goes down or changes, the latest version is kept. This would involve some kind of session management and storage configuration in Spring's settings.

I'm also curious about how tokens are stored on the client side versus the server side. I think Spring Security uses the Spring Data Store for persistent storage, so tokens might be stored there so that they can be retrieved by clients even after a service restart.

Putting this all together, it seems like Spring Security handles JWT tokens by integrating with Spring Boot's configuration and libraries to manage token generation, validation, expiration, and persistence. It likely uses OAuth2 mechanisms through its SDK, stores the token internally in memory or on disk, and manages the access flow between clients and servers using standard OAuth practices.

I'm not entirely sure about all the specifics, but this is how I understand it so far. Maybe consulting the Spring Security documentation would provide more detailed information on each component involved.
</think>

Spring Security effectively handles JWT tokens by integrating with OAuth2 authentication mechanisms through its SDK. Here's a structured overview of how this is achieved:

1. **OAuth Framework Integration**: Spring Security utilizes the OAuth2 framework, which defines authorization flows using HTTP requests to specific URLs.

2. **Configuration Setup**: The configuration file (e.g., `spring-boot:auth:token-authorization-flows`) specifies paths and raw parameters required for OAuth flow execution, ensuring that token generation and validation happen correctly.

3. **WebAuthService Management**: Utilizes `Spring Rest WebAuthService` to manage the authorization process, including fetching, validating, authenticating, and re-issuing tokens.

4. **Token Storage**: Spring Security internally stores JWT data in its session storage using the `Spring Data Store`, allowing for persistent access regardless of service interruptions.

5. **Token Validity Management**: Ensures token validity through expiration mechanisms, managing tokens that are invalidated by changing their expiration status and potentially rolling them over as needed.

6. **Client-Server Communication**: Abstracts away OAuth-specific client calls (e.g., `http://localhost:8080/v1/auth/`), using the SDK to handle token requests, validation, and storage.

7. **Authentication Flow Management**: Manages the flow from client credentials to server authentication, ensuring each step is correctly handled by appropriate classes.

In summary, Spring Security leverages Spring Boot's configuration and libraries to securely manage JWT tokens, integrating them into OAuth flows, storing them internally, and managing their lifecycle effectively.
2025-06-14 22:00:13.182 [http-nio-8080-exec-5] DEBUG p.u.s.t.service.TranslationService - 번역 완료: QUERY LENGTH LIMIT EXCEEDED. MAX ALLOWED QUERY : 500 CHARS
2025-06-14 22:00:13.182 [http-nio-8080-exec-5] DEBUG p.upik.shared.ai.service.AIService - DeepSeek AI response (translated to Korean): QUERY LENGTH LIMIT EXCEEDED. MAX ALLOWED QUERY : 500 CHARS
2025-06-14 22:02:26.002 [SpringApplicationShutdownHook] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Commencing graceful shutdown. Waiting for active requests to complete
2025-06-14 22:02:26.010 [tomcat-shutdown] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Graceful shutdown complete
2025-06-14 22:02:26.025 [SpringApplicationShutdownHook] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Closing JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:02:26.035 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown initiated...
2025-06-14 22:02:26.147 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown completed.
2025-06-14 22:02:40.248 [background-preinit] INFO  o.h.validator.internal.util.Version - HV000001: Hibernate Validator 8.0.2.Final
2025-06-14 22:02:40.299 [main] INFO  pluto.upik.UpikApplication - Starting UpikApplication using Java 21.0.4 with PID 16324 (/Users/upik/build/classes/java/main started by heodongun in /Users/upik)
2025-06-14 22:02:40.300 [main] DEBUG pluto.upik.UpikApplication - Running with Spring Boot v3.5.0, Spring v6.2.7
2025-06-14 22:02:40.301 [main] INFO  pluto.upik.UpikApplication - No active profile set, falling back to 1 default profile: "default"
2025-06-14 22:02:41.978 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-06-14 22:02:42.070 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 80 ms. Found 5 JPA repository interfaces.
2025-06-14 22:02:42.358 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port 8080 (http)
2025-06-14 22:02:42.365 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2025-06-14 22:02:42.366 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-06-14 22:02:42.366 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.41]
2025-06-14 22:02:42.390 [main] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
2025-06-14 22:02:42.390 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 2052 ms
2025-06-14 22:02:42.456 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
2025-06-14 22:02:43.703 [main] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection org.mariadb.jdbc.Connection@34549979
2025-06-14 22:02:43.704 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
2025-06-14 22:02:43.736 [main] INFO  o.h.jpa.internal.util.LogHelper - HHH000204: Processing PersistenceUnitInfo [name: default]
2025-06-14 22:02:43.772 [main] INFO  org.hibernate.Version - HHH000412: Hibernate ORM core version 6.6.15.Final
2025-06-14 22:02:43.792 [main] INFO  o.h.c.i.RegionFactoryInitiator - HHH000026: Second-level cache disabled
2025-06-14 22:02:43.978 [main] INFO  o.s.o.j.p.SpringPersistenceUnitInfo - No LoadTimeWeaver setup: ignoring JPA class transformer
2025-06-14 22:02:44.434 [main] INFO  o.hibernate.orm.connections.pooling - HHH10001005: Database info:
	Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
	Database driver: undefined/unknown
	Database version: 10.11.11
	Autocommit mode: undefined/unknown
	Isolation level: undefined/unknown
	Minimum pool size: undefined/unknown
	Maximum pool size: undefined/unknown
2025-06-14 22:02:44.911 [main] INFO  o.h.e.t.j.p.i.JtaPlatformInitiator - HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-06-14 22:02:44.912 [main] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:02:45.061 [main] INFO  o.s.d.j.r.query.QueryEnhancerFactory - Hibernate is in classpath; If applicable, HQL parser will be used.
2025-06-14 22:02:45.496 [main] WARN  o.s.b.a.o.j.JpaBaseConfiguration$JpaWebConfiguration - spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-06-14 22:02:45.923 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2025-06-14 22:02:45.929 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port 8080 (http) with context path '/'
2025-06-14 22:02:45.938 [main] INFO  pluto.upik.UpikApplication - Started UpikApplication in 6.204 seconds (process running for 6.867)
2025-06-14 22:02:49.410 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-06-14 22:02:49.411 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2025-06-14 22:02:49.414 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 3 ms
2025-06-14 22:02:50.114 [http-nio-8080-exec-9] INFO  o.s.api.AbstractOpenApiResource - Init duration for springdoc-openapi is: 286 ms
2025-06-14 22:03:11.121 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (original): 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 22:03:11.122 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 22:03:13.501 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: How does Spring Security implement the JWT token?
2025-06-14 22:03:13.501 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (translated to English): How does Spring Security implement the JWT token?
2025-06-14 22:04:02.600 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - Received DeepSeek AI response (English): <think>
Okay, so I need to figure out how Spring Security implements the JWT token. I remember that Spring Security uses various libraries and third-party services for security in Java applications, but JWTs are something I've heard about before, especially since they're used in various authentication contexts like API endpoints.

First, I think about what a JWT is. It's a type of short-lived token used in web applications to authenticate requests from clients to APIs or other parts of an application. Each token usually contains a unique value, a time-to-expiration (TOE), and possibly some timestamp data.

I know that Spring Security has its own implementation of the Spring Security API, which includes JWT as part of its security features. So I should look into how it interacts with Spring's API.

Wait, Spring Security doesn't handle its own token storage; they rely on the Spring Data Store for storing sensitive data like tokens. That means Spring Security uses Spring Data to hold the JWT values stored, allowing the Java runtime to manage them securely.

So, when a client makes an API request that requires JWT authentication, the application needs to retrieve the stored token from Spring's Data Store. How does this happen? I think it might involve some custom code or classes that interact with the Data Store.

I recall that Spring Security has something called Spring Security Web for RESTful APIs and Spring Security API for Spring Boot Applications. The latter includes a security feature called Spring Security Web which uses JWT as part of its authentication mechanism.

In Spring Security Web, there's probably a way to retrieve the stored token using a specific method. I remember seeing classes like DefaultWebAuthenticator which might have methods related to JWT retrieval.

Maybe something like getTokenFromRest() in some authenticator class that can be called when a request comes from an HTTP client. The authenticateHTTPRequest method would then call this and store it into the Data Store if it's not expired.

Wait, so the process is: when a request is made, Spring's Web Security authenticator retrieves the token from Spring Data. If the token is valid (i.e., its expiration time is still in the future), it stores the token in the Data Store and returns it to the client. If the token has expired, it might throw an exception or return null.

I think I've seen something like that before. So Spring Security authenticator methods handle getting the stored token, validating it based on expiration time, storing it, and then returning it so the client can use it for authentication.

But how exactly does this get implemented? Maybe there's a class in Spring Security Web which handles the token retrieval logic. Perhaps something like DefaultWebAuthenticator which has a method to retrieve the stored token from Data Store.

Additionally, I believe that Spring Security uses Spring Data in-memory storage by default. So if the app is using an in-memory instance, it might directly access the Data Store through Spring's internal data model. But for applications that use Spring Boot, which doesn't have in-memory instances, they'd need to use the out-of-memory model.

Another thing I should consider is how JWT expiration works. Since JWTs are short-lived, each token needs an expiration time when it should be replaced. If stored in Spring Data, how does Spring Security handle these times? Maybe there's a timestamp data that tracks the expiration.

I think that during retrieval, Spring Security can compare the current toea time with the stored value and throw an exception if it's expired. That way, applications get an error when they should receive the token.

But I'm not entirely sure about all the specifics. Let me try to outline what steps are involved:

1. When a request comes from an HTTP client (like JAX-RS), Spring Security Web authenticator retrieves the stored token.
2. The method checks if the token is valid by comparing its expiration time with the current system clock.
3. If it's expired, it throws an exception indicating that the token has already been used or invalid.
4. If the token is still valid, it stores the JWT value in Spring Data and returns it to the client for authentication.

I also remember that Spring Security Web provides a way to authenticate requests using the API endpoint. So each time a request is made, it calls Spring's authenticator methods to get the token and then checks its expiration status.

In terms of code structure, perhaps there are classes or methods in Spring Security Web which handle token retrieval. For example, an AuthenticationRequest class that uses DefaultWebAuthenticator and retrieves the token via getTokenFromRest(). Then, this token is stored in the Data Store if it's valid.

I think it's also important to note that Spring Security doesn't use its own data storage for tokens; instead, they rely on Spring Data for storing sensitive data. This separation of concerns makes handling sensitive information more secure because Spring Data manages their storage in compliance with IAM and other security standards.

So, putting it all together, the process involves Spring Security authenticator methods retrieving a token from the Spring Data Store, checking its validity based on expiration, storing or throwing an error if expired, and then returning the token for the client to use. The authentication mechanism relies heavily on Spring Security's Web framework and Spring Data's in-memory storage.

I might be missing some details, though. I should check if Spring Security uses any specific libraries or services for this process. Maybe something like Spring Data or Spring Security Web itself handling the JWT retrieval. Also, how does it handle multiple tokens being stored? Is each token stored separately, and only used once per request?

Overall, the implementation seems to be tightly integrated with Spring Data and Spring Security Web, leveraging their frameworks to manage security for JWT-based authentication in Java web applications.
</think>

Spring Security implements the JWT token through its API framework, specifically Spring Security Web, which provides a robust method for handling secure requests using JWT. Here's a structured explanation of how it works:

1. **Authentication Mechanism**: Spring Security Web uses Spring Data, an open-source in-memory data store, to store sensitive data like tokens. This allows Spring Security to manage tokens securely without storing them on the Java runtime.

2. **Token Retrieval**: When a request is made via HTTP clients (e.g., JAX-RS), Spring's authenticator methods retrieve the stored token from Spring Data. The authentication system checks if the token's expiration time remains valid.

3. **Expiry Check**: The authenticator method compares the current toea time with the stored expiration value. If expired, an error is thrown indicating the token has been used or invalid.

4. **Token Storage**: If the token is still valid, it is stored in Spring Data and returned to the client for authentication. This ensures that only valid tokens are used, enhancing security by preventing unauthorized access.

5. **Data Model Integration**: Spring Data's in-memory storage allows seamless integration with Java Web Applications (JWAs), ensuring efficient token handling without external dependencies.

6. **Web API Handling**: Each application that requires authentication uses the Web API endpoint to call Spring Security Web authenticator methods, which handle JWT retrieval and validation internally.

In summary, Spring Security leverages Spring Data and Spring Security Web to securely manage JWT tokens, ensuring timely expiration and reliable storage for sensitive data in Java web applications.
2025-06-14 22:04:02.602 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: <think>
Okay, so I need to figure out how Spring Security implements the JWT token. I remember that Spring Security uses various libraries and third-party services for security in Java applications, but JWTs are something I've heard about before, especially since they're used in various authentication contexts like API endpoints.

First, I think about what a JWT is. It's a type of short-lived token used in web applications to authenticate requests from clients to APIs or other parts of an application. Each token usually contains a unique value, a time-to-expiration (TOE), and possibly some timestamp data.

I know that Spring Security has its own implementation of the Spring Security API, which includes JWT as part of its security features. So I should look into how it interacts with Spring's API.

Wait, Spring Security doesn't handle its own token storage; they rely on the Spring Data Store for storing sensitive data like tokens. That means Spring Security uses Spring Data to hold the JWT values stored, allowing the Java runtime to manage them securely.

So, when a client makes an API request that requires JWT authentication, the application needs to retrieve the stored token from Spring's Data Store. How does this happen? I think it might involve some custom code or classes that interact with the Data Store.

I recall that Spring Security has something called Spring Security Web for RESTful APIs and Spring Security API for Spring Boot Applications. The latter includes a security feature called Spring Security Web which uses JWT as part of its authentication mechanism.

In Spring Security Web, there's probably a way to retrieve the stored token using a specific method. I remember seeing classes like DefaultWebAuthenticator which might have methods related to JWT retrieval.

Maybe something like getTokenFromRest() in some authenticator class that can be called when a request comes from an HTTP client. The authenticateHTTPRequest method would then call this and store it into the Data Store if it's not expired.

Wait, so the process is: when a request is made, Spring's Web Security authenticator retrieves the token from Spring Data. If the token is valid (i.e., its expiration time is still in the future), it stores the token in the Data Store and returns it to the client. If the token has expired, it might throw an exception or return null.

I think I've seen something like that before. So Spring Security authenticator methods handle getting the stored token, validating it based on expiration time, storing it, and then returning it so the client can use it for authentication.

But how exactly does this get implemented? Maybe there's a class in Spring Security Web which handles the token retrieval logic. Perhaps something like DefaultWebAuthenticator which has a method to retrieve the stored token from Data Store.

Additionally, I believe that Spring Security uses Spring Data in-memory storage by default. So if the app is using an in-memory instance, it might directly access the Data Store through Spring's internal data model. But for applications that use Spring Boot, which doesn't have in-memory instances, they'd need to use the out-of-memory model.

Another thing I should consider is how JWT expiration works. Since JWTs are short-lived, each token needs an expiration time when it should be replaced. If stored in Spring Data, how does Spring Security handle these times? Maybe there's a timestamp data that tracks the expiration.

I think that during retrieval, Spring Security can compare the current toea time with the stored value and throw an exception if it's expired. That way, applications get an error when they should receive the token.

But I'm not entirely sure about all the specifics. Let me try to outline what steps are involved:

1. When a request comes from an HTTP client (like JAX-RS), Spring Security Web authenticator retrieves the stored token.
2. The method checks if the token is valid by comparing its expiration time with the current system clock.
3. If it's expired, it throws an exception indicating that the token has already been used or invalid.
4. If the token is still valid, it stores the JWT value in Spring Data and returns it to the client for authentication.

I also remember that Spring Security Web provides a way to authenticate requests using the API endpoint. So each time a request is made, it calls Spring's authenticator methods to get the token and then checks its expiration status.

In terms of code structure, perhaps there are classes or methods in Spring Security Web which handle token retrieval. For example, an AuthenticationRequest class that uses DefaultWebAuthenticator and retrieves the token via getTokenFromRest(). Then, this token is stored in the Data Store if it's valid.

I think it's also important to note that Spring Security doesn't use its own data storage for tokens; instead, they rely on Spring Data for storing sensitive data. This separation of concerns makes handling sensitive information more secure because Spring Data manages their storage in compliance with IAM and other security standards.

So, putting it all together, the process involves Spring Security authenticator methods retrieving a token from the Spring Data Store, checking its validity based on expiration, storing or throwing an error if expired, and then returning the token for the client to use. The authentication mechanism relies heavily on Spring Security's Web framework and Spring Data's in-memory storage.

I might be missing some details, though. I should check if Spring Security uses any specific libraries or services for this process. Maybe something like Spring Data or Spring Security Web itself handling the JWT retrieval. Also, how does it handle multiple tokens being stored? Is each token stored separately, and only used once per request?

Overall, the implementation seems to be tightly integrated with Spring Data and Spring Security Web, leveraging their frameworks to manage security for JWT-based authentication in Java web applications.
</think>

Spring Security implements the JWT token through its API framework, specifically Spring Security Web, which provides a robust method for handling secure requests using JWT. Here's a structured explanation of how it works:

1. **Authentication Mechanism**: Spring Security Web uses Spring Data, an open-source in-memory data store, to store sensitive data like tokens. This allows Spring Security to manage tokens securely without storing them on the Java runtime.

2. **Token Retrieval**: When a request is made via HTTP clients (e.g., JAX-RS), Spring's authenticator methods retrieve the stored token from Spring Data. The authentication system checks if the token's expiration time remains valid.

3. **Expiry Check**: The authenticator method compares the current toea time with the stored expiration value. If expired, an error is thrown indicating the token has been used or invalid.

4. **Token Storage**: If the token is still valid, it is stored in Spring Data and returned to the client for authentication. This ensures that only valid tokens are used, enhancing security by preventing unauthorized access.

5. **Data Model Integration**: Spring Data's in-memory storage allows seamless integration with Java Web Applications (JWAs), ensuring efficient token handling without external dependencies.

6. **Web API Handling**: Each application that requires authentication uses the Web API endpoint to call Spring Security Web authenticator methods, which handle JWT retrieval and validation internally.

In summary, Spring Security leverages Spring Data and Spring Security Web to securely manage JWT tokens, ensuring timely expiration and reliable storage for sensitive data in Java web applications.
2025-06-14 22:04:03.560 [http-nio-8080-exec-10] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException: 414 URI Too Long: "<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"><EOL><html><head><EOL><title>414 Request-URI Too Long</title><EOL></head><body><EOL><h1>Request-URI Too Long</h1><EOL><p>The requested URL's length exceeds the capacity<EOL>limit for this server.<br /><EOL></p><EOL><hr><EOL><address>Apache/2.4.41 (Ubuntu) Server at API.mymemory.translated.net Port 80</address><EOL></body></html><EOL>"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:136)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:75)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:04:03.578 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - DeepSeek AI response (translated to Korean): <think>
Okay, so I need to figure out how Spring Security implements the JWT token. I remember that Spring Security uses various libraries and third-party services for security in Java applications, but JWTs are something I've heard about before, especially since they're used in various authentication contexts like API endpoints.

First, I think about what a JWT is. It's a type of short-lived token used in web applications to authenticate requests from clients to APIs or other parts of an application. Each token usually contains a unique value, a time-to-expiration (TOE), and possibly some timestamp data.

I know that Spring Security has its own implementation of the Spring Security API, which includes JWT as part of its security features. So I should look into how it interacts with Spring's API.

Wait, Spring Security doesn't handle its own token storage; they rely on the Spring Data Store for storing sensitive data like tokens. That means Spring Security uses Spring Data to hold the JWT values stored, allowing the Java runtime to manage them securely.

So, when a client makes an API request that requires JWT authentication, the application needs to retrieve the stored token from Spring's Data Store. How does this happen? I think it might involve some custom code or classes that interact with the Data Store.

I recall that Spring Security has something called Spring Security Web for RESTful APIs and Spring Security API for Spring Boot Applications. The latter includes a security feature called Spring Security Web which uses JWT as part of its authentication mechanism.

In Spring Security Web, there's probably a way to retrieve the stored token using a specific method. I remember seeing classes like DefaultWebAuthenticator which might have methods related to JWT retrieval.

Maybe something like getTokenFromRest() in some authenticator class that can be called when a request comes from an HTTP client. The authenticateHTTPRequest method would then call this and store it into the Data Store if it's not expired.

Wait, so the process is: when a request is made, Spring's Web Security authenticator retrieves the token from Spring Data. If the token is valid (i.e., its expiration time is still in the future), it stores the token in the Data Store and returns it to the client. If the token has expired, it might throw an exception or return null.

I think I've seen something like that before. So Spring Security authenticator methods handle getting the stored token, validating it based on expiration time, storing it, and then returning it so the client can use it for authentication.

But how exactly does this get implemented? Maybe there's a class in Spring Security Web which handles the token retrieval logic. Perhaps something like DefaultWebAuthenticator which has a method to retrieve the stored token from Data Store.

Additionally, I believe that Spring Security uses Spring Data in-memory storage by default. So if the app is using an in-memory instance, it might directly access the Data Store through Spring's internal data model. But for applications that use Spring Boot, which doesn't have in-memory instances, they'd need to use the out-of-memory model.

Another thing I should consider is how JWT expiration works. Since JWTs are short-lived, each token needs an expiration time when it should be replaced. If stored in Spring Data, how does Spring Security handle these times? Maybe there's a timestamp data that tracks the expiration.

I think that during retrieval, Spring Security can compare the current toea time with the stored value and throw an exception if it's expired. That way, applications get an error when they should receive the token.

But I'm not entirely sure about all the specifics. Let me try to outline what steps are involved:

1. When a request comes from an HTTP client (like JAX-RS), Spring Security Web authenticator retrieves the stored token.
2. The method checks if the token is valid by comparing its expiration time with the current system clock.
3. If it's expired, it throws an exception indicating that the token has already been used or invalid.
4. If the token is still valid, it stores the JWT value in Spring Data and returns it to the client for authentication.

I also remember that Spring Security Web provides a way to authenticate requests using the API endpoint. So each time a request is made, it calls Spring's authenticator methods to get the token and then checks its expiration status.

In terms of code structure, perhaps there are classes or methods in Spring Security Web which handle token retrieval. For example, an AuthenticationRequest class that uses DefaultWebAuthenticator and retrieves the token via getTokenFromRest(). Then, this token is stored in the Data Store if it's valid.

I think it's also important to note that Spring Security doesn't use its own data storage for tokens; instead, they rely on Spring Data for storing sensitive data. This separation of concerns makes handling sensitive information more secure because Spring Data manages their storage in compliance with IAM and other security standards.

So, putting it all together, the process involves Spring Security authenticator methods retrieving a token from the Spring Data Store, checking its validity based on expiration, storing or throwing an error if expired, and then returning the token for the client to use. The authentication mechanism relies heavily on Spring Security's Web framework and Spring Data's in-memory storage.

I might be missing some details, though. I should check if Spring Security uses any specific libraries or services for this process. Maybe something like Spring Data or Spring Security Web itself handling the JWT retrieval. Also, how does it handle multiple tokens being stored? Is each token stored separately, and only used once per request?

Overall, the implementation seems to be tightly integrated with Spring Data and Spring Security Web, leveraging their frameworks to manage security for JWT-based authentication in Java web applications.
</think>

Spring Security implements the JWT token through its API framework, specifically Spring Security Web, which provides a robust method for handling secure requests using JWT. Here's a structured explanation of how it works:

1. **Authentication Mechanism**: Spring Security Web uses Spring Data, an open-source in-memory data store, to store sensitive data like tokens. This allows Spring Security to manage tokens securely without storing them on the Java runtime.

2. **Token Retrieval**: When a request is made via HTTP clients (e.g., JAX-RS), Spring's authenticator methods retrieve the stored token from Spring Data. The authentication system checks if the token's expiration time remains valid.

3. **Expiry Check**: The authenticator method compares the current toea time with the stored expiration value. If expired, an error is thrown indicating the token has been used or invalid.

4. **Token Storage**: If the token is still valid, it is stored in Spring Data and returned to the client for authentication. This ensures that only valid tokens are used, enhancing security by preventing unauthorized access.

5. **Data Model Integration**: Spring Data's in-memory storage allows seamless integration with Java Web Applications (JWAs), ensuring efficient token handling without external dependencies.

6. **Web API Handling**: Each application that requires authentication uses the Web API endpoint to call Spring Security Web authenticator methods, which handle JWT retrieval and validation internally.

In summary, Spring Security leverages Spring Data and Spring Security Web to securely manage JWT tokens, ensuring timely expiration and reliable storage for sensitive data in Java web applications.
2025-06-14 22:04:03.578 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - AI response after removing think tags: <think>
Okay, so I need to figure out how Spring Security implements the JWT token. I remember that Spring Security uses various libraries and third-party services for security in Java applications, but JWTs are something I've heard about before, especially since they're used in various authentication contexts like API endpoints.

First, I think about what a JWT is. It's a type of short-lived token used in web applications to authenticate requests from clients to APIs or other parts of an application. Each token usually contains a unique value, a time-to-expiration (TOE), and possibly some timestamp data.

I know that Spring Security has its own implementation of the Spring Security API, which includes JWT as part of its security features. So I should look into how it interacts with Spring's API.

Wait, Spring Security doesn't handle its own token storage; they rely on the Spring Data Store for storing sensitive data like tokens. That means Spring Security uses Spring Data to hold the JWT values stored, allowing the Java runtime to manage them securely.

So, when a client makes an API request that requires JWT authentication, the application needs to retrieve the stored token from Spring's Data Store. How does this happen? I think it might involve some custom code or classes that interact with the Data Store.

I recall that Spring Security has something called Spring Security Web for RESTful APIs and Spring Security API for Spring Boot Applications. The latter includes a security feature called Spring Security Web which uses JWT as part of its authentication mechanism.

In Spring Security Web, there's probably a way to retrieve the stored token using a specific method. I remember seeing classes like DefaultWebAuthenticator which might have methods related to JWT retrieval.

Maybe something like getTokenFromRest() in some authenticator class that can be called when a request comes from an HTTP client. The authenticateHTTPRequest method would then call this and store it into the Data Store if it's not expired.

Wait, so the process is: when a request is made, Spring's Web Security authenticator retrieves the token from Spring Data. If the token is valid (i.e., its expiration time is still in the future), it stores the token in the Data Store and returns it to the client. If the token has expired, it might throw an exception or return null.

I think I've seen something like that before. So Spring Security authenticator methods handle getting the stored token, validating it based on expiration time, storing it, and then returning it so the client can use it for authentication.

But how exactly does this get implemented? Maybe there's a class in Spring Security Web which handles the token retrieval logic. Perhaps something like DefaultWebAuthenticator which has a method to retrieve the stored token from Data Store.

Additionally, I believe that Spring Security uses Spring Data in-memory storage by default. So if the app is using an in-memory instance, it might directly access the Data Store through Spring's internal data model. But for applications that use Spring Boot, which doesn't have in-memory instances, they'd need to use the out-of-memory model.

Another thing I should consider is how JWT expiration works. Since JWTs are short-lived, each token needs an expiration time when it should be replaced. If stored in Spring Data, how does Spring Security handle these times? Maybe there's a timestamp data that tracks the expiration.

I think that during retrieval, Spring Security can compare the current toea time with the stored value and throw an exception if it's expired. That way, applications get an error when they should receive the token.

But I'm not entirely sure about all the specifics. Let me try to outline what steps are involved:

1. When a request comes from an HTTP client (like JAX-RS), Spring Security Web authenticator retrieves the stored token.
2. The method checks if the token is valid by comparing its expiration time with the current system clock.
3. If it's expired, it throws an exception indicating that the token has already been used or invalid.
4. If the token is still valid, it stores the JWT value in Spring Data and returns it to the client for authentication.

I also remember that Spring Security Web provides a way to authenticate requests using the API endpoint. So each time a request is made, it calls Spring's authenticator methods to get the token and then checks its expiration status.

In terms of code structure, perhaps there are classes or methods in Spring Security Web which handle token retrieval. For example, an AuthenticationRequest class that uses DefaultWebAuthenticator and retrieves the token via getTokenFromRest(). Then, this token is stored in the Data Store if it's valid.

I think it's also important to note that Spring Security doesn't use its own data storage for tokens; instead, they rely on Spring Data for storing sensitive data. This separation of concerns makes handling sensitive information more secure because Spring Data manages their storage in compliance with IAM and other security standards.

So, putting it all together, the process involves Spring Security authenticator methods retrieving a token from the Spring Data Store, checking its validity based on expiration, storing or throwing an error if expired, and then returning the token for the client to use. The authentication mechanism relies heavily on Spring Security's Web framework and Spring Data's in-memory storage.

I might be missing some details, though. I should check if Spring Security uses any specific libraries or services for this process. Maybe something like Spring Data or Spring Security Web itself handling the JWT retrieval. Also, how does it handle multiple tokens being stored? Is each token stored separately, and only used once per request?

Overall, the implementation seems to be tightly integrated with Spring Data and Spring Security Web, leveraging their frameworks to manage security for JWT-based authentication in Java web applications.
</think>

Spring Security implements the JWT token through its API framework, specifically Spring Security Web, which provides a robust method for handling secure requests using JWT. Here's a structured explanation of how it works:

1. **Authentication Mechanism**: Spring Security Web uses Spring Data, an open-source in-memory data store, to store sensitive data like tokens. This allows Spring Security to manage tokens securely without storing them on the Java runtime.

2. **Token Retrieval**: When a request is made via HTTP clients (e.g., JAX-RS), Spring's authenticator methods retrieve the stored token from Spring Data. The authentication system checks if the token's expiration time remains valid.

3. **Expiry Check**: The authenticator method compares the current toea time with the stored expiration value. If expired, an error is thrown indicating the token has been used or invalid.

4. **Token Storage**: If the token is still valid, it is stored in Spring Data and returned to the client for authentication. This ensures that only valid tokens are used, enhancing security by preventing unauthorized access.

5. **Data Model Integration**: Spring Data's in-memory storage allows seamless integration with Java Web Applications (JWAs), ensuring efficient token handling without external dependencies.

6. **Web API Handling**: Each application that requires authentication uses the Web API endpoint to call Spring Security Web authenticator methods, which handle JWT retrieval and validation internally.

In summary, Spring Security leverages Spring Data and Spring Security Web to securely manage JWT tokens, ensuring timely expiration and reliable storage for sensitive data in Java web applications.
2025-06-14 22:12:52.170 [SpringApplicationShutdownHook] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Commencing graceful shutdown. Waiting for active requests to complete
2025-06-14 22:12:52.184 [tomcat-shutdown] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Graceful shutdown complete
2025-06-14 22:12:52.192 [SpringApplicationShutdownHook] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Closing JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:12:52.196 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown initiated...
2025-06-14 22:12:52.253 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown completed.
2025-06-14 22:13:01.741 [background-preinit] INFO  o.h.validator.internal.util.Version - HV000001: Hibernate Validator 8.0.2.Final
2025-06-14 22:13:01.764 [main] INFO  pluto.upik.UpikApplication - Starting UpikApplication using Java 21.0.4 with PID 16502 (/Users/upik/build/classes/java/main started by heodongun in /Users/upik)
2025-06-14 22:13:01.764 [main] DEBUG pluto.upik.UpikApplication - Running with Spring Boot v3.5.0, Spring v6.2.7
2025-06-14 22:13:01.764 [main] INFO  pluto.upik.UpikApplication - No active profile set, falling back to 1 default profile: "default"
2025-06-14 22:13:02.202 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-06-14 22:13:02.274 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 68 ms. Found 5 JPA repository interfaces.
2025-06-14 22:13:02.520 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port 8080 (http)
2025-06-14 22:13:02.526 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2025-06-14 22:13:02.527 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-06-14 22:13:02.527 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.41]
2025-06-14 22:13:02.552 [main] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
2025-06-14 22:13:02.552 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 771 ms
2025-06-14 22:13:02.616 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
2025-06-14 22:13:03.841 [main] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection org.mariadb.jdbc.Connection@7de3206d
2025-06-14 22:13:03.844 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
2025-06-14 22:13:03.882 [main] INFO  o.h.jpa.internal.util.LogHelper - HHH000204: Processing PersistenceUnitInfo [name: default]
2025-06-14 22:13:03.919 [main] INFO  org.hibernate.Version - HHH000412: Hibernate ORM core version 6.6.15.Final
2025-06-14 22:13:03.935 [main] INFO  o.h.c.i.RegionFactoryInitiator - HHH000026: Second-level cache disabled
2025-06-14 22:13:04.078 [main] INFO  o.s.o.j.p.SpringPersistenceUnitInfo - No LoadTimeWeaver setup: ignoring JPA class transformer
2025-06-14 22:13:04.527 [main] INFO  o.hibernate.orm.connections.pooling - HHH10001005: Database info:
	Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
	Database driver: undefined/unknown
	Database version: 10.11.11
	Autocommit mode: undefined/unknown
	Isolation level: undefined/unknown
	Minimum pool size: undefined/unknown
	Maximum pool size: undefined/unknown
2025-06-14 22:13:04.972 [main] INFO  o.h.e.t.j.p.i.JtaPlatformInitiator - HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-06-14 22:13:04.973 [main] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:13:05.115 [main] INFO  o.s.d.j.r.query.QueryEnhancerFactory - Hibernate is in classpath; If applicable, HQL parser will be used.
2025-06-14 22:13:05.534 [main] WARN  o.s.b.a.o.j.JpaBaseConfiguration$JpaWebConfiguration - spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-06-14 22:13:05.922 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2025-06-14 22:13:05.927 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port 8080 (http) with context path '/'
2025-06-14 22:13:05.935 [main] INFO  pluto.upik.UpikApplication - Started UpikApplication in 4.392 seconds (process running for 9.794)
2025-06-14 22:14:21.474 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-06-14 22:14:21.475 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2025-06-14 22:14:21.478 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 3 ms
2025-06-14 22:14:21.572 [http-nio-8080-exec-1] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (original): 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 22:14:21.572 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 22:14:24.067 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: How does Spring Security implement the JWT token?
2025-06-14 22:14:24.068 [http-nio-8080-exec-1] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (translated to English): How does Spring Security implement the JWT token?
2025-06-14 22:14:51.597 [http-nio-8080-exec-1] DEBUG p.upik.shared.ai.service.AIService - Received DeepSeek AI response (English): <think>
Okay, so I'm trying to figure out how Spring Security implements the JWT token. I know that JWT stands for JavaScript-Short-lived Token, which is a way to secure tokens in web applications. But I'm not entirely sure about all the details, especially since Spring Security uses it with other libraries like Spring Web and Spring Security API.

First, I remember that JWT involves something called a salt. From what I've heard before, the salt is a random string used along with the hash of the token to create each unique signature for the token. So maybe Spring Security uses a salt when handling tokens? But wait, does it use an internal salt stored on the server or external storage?

I think Spring Web provides some utility classes that handle JWT encryption and deserialization. They have methods like encryptToken(), which probably takes the token and the key to hash, then applies the salt. Then there's decryptToken(), which would take the encrypted byte stream and return the original token and key.

But how does this integrate with Spring Security? I know Spring Web has a Token class that holds the token data, but maybe it uses something like Spring Sec or Spring Play for handling JWT specifically. Wait, did Spring Security use Spring Play as their API in a previous version? If so, Spring Play might handle token validation and encryption using custom classes.

I'm trying to recall if there's an encryption class in Spring Play that implements the JSPToken interface. If not, maybe they used different libraries or extensions. I think some people suggest using Spring Security's Play package with specific modules for JWT handling, but I'm not sure if that's still active or needed anymore.

I also remember that when dealing with tokens and security, especially in Spring, there might be some custom classes or plugins involved. Maybe they use the javax.xml module to handle token validation and encryption. That could mean that even if Spring Security doesn't have its own implementation of JWT, it relies on third-party XML-based libraries for token handling.

So putting it all together: Spring Security handles JWT tokens by possibly using internal salts in their classes or relying on external libraries like Play with XML modules to manage the token validation and encryption. They might also use custom classes from the Spring Security API or other providers if such implementations exist.

I think I need to verify this, but based on what I remember, Spring Security primarily relies on third-party libraries for handling JWT tokens in their application security layer.
</think>

Spring Security implements the JWT token through several mechanisms, which can be summarized as follows:

1. **Salt Utilization**: The salt is a random string used with each token hash to create unique signatures. This ensures that even if two different tokens have the same hash (using a collision-resistant hashing algorithm like SHA-512), they will result in different JWT signatures.

2. **Encryption and Decryption**: Spring Security uses Spring Play's `jsp` package, which includes classes implementing the `JSPToken` interface for handling token validation and encryption. These classes handle encryption using a custom class that applies the salt to each token before hashing.

3. **Internal Salts on Servers or External Storage**: While not directly implemented within Spring Security, these salts are typically stored locally on the server or external storage (like USB) to prevent unauthorized decryption without proper key handling.

4. **JSP and SAX Event**: JPA's `sax` event is used for validation, allowing tokens to be validated when displayed on a page. This integration ensures token integrity during application execution.

5. **Custom Classes from API Providers**: Some providers like Spring Play might offer JWT-related classes that provide encryption handling through third-party libraries.

In summary, while Spring Security may not have an internal implementation of the JWT mechanism, it relies on external libraries and custom classes within its framework to handle token validation, encryption, and deserialization.
2025-06-14 22:14:51.598 [http-nio-8080-exec-1] DEBUG p.upik.shared.ai.service.AIService - AI response after removing think tags: <think>
Okay, so I'm trying to figure out how Spring Security implements the JWT token. I know that JWT stands for JavaScript-Short-lived Token, which is a way to secure tokens in web applications. But I'm not entirely sure about all the details, especially since Spring Security uses it with other libraries like Spring Web and Spring Security API.

First, I remember that JWT involves something called a salt. From what I've heard before, the salt is a random string used along with the hash of the token to create each unique signature for the token. So maybe Spring Security uses a salt when handling tokens? But wait, does it use an internal salt stored on the server or external storage?

I think Spring Web provides some utility classes that handle JWT encryption and deserialization. They have methods like encryptToken(), which probably takes the token and the key to hash, then applies the salt. Then there's decryptToken(), which would take the encrypted byte stream and return the original token and key.

But how does this integrate with Spring Security? I know Spring Web has a Token class that holds the token data, but maybe it uses something like Spring Sec or Spring Play for handling JWT specifically. Wait, did Spring Security use Spring Play as their API in a previous version? If so, Spring Play might handle token validation and encryption using custom classes.

I'm trying to recall if there's an encryption class in Spring Play that implements the JSPToken interface. If not, maybe they used different libraries or extensions. I think some people suggest using Spring Security's Play package with specific modules for JWT handling, but I'm not sure if that's still active or needed anymore.

I also remember that when dealing with tokens and security, especially in Spring, there might be some custom classes or plugins involved. Maybe they use the javax.xml module to handle token validation and encryption. That could mean that even if Spring Security doesn't have its own implementation of JWT, it relies on third-party XML-based libraries for token handling.

So putting it all together: Spring Security handles JWT tokens by possibly using internal salts in their classes or relying on external libraries like Play with XML modules to manage the token validation and encryption. They might also use custom classes from the Spring Security API or other providers if such implementations exist.

I think I need to verify this, but based on what I remember, Spring Security primarily relies on third-party libraries for handling JWT tokens in their application security layer.
</think>

Spring Security implements the JWT token through several mechanisms, which can be summarized as follows:

1. **Salt Utilization**: The salt is a random string used with each token hash to create unique signatures. This ensures that even if two different tokens have the same hash (using a collision-resistant hashing algorithm like SHA-512), they will result in different JWT signatures.

2. **Encryption and Decryption**: Spring Security uses Spring Play's `jsp` package, which includes classes implementing the `JSPToken` interface for handling token validation and encryption. These classes handle encryption using a custom class that applies the salt to each token before hashing.

3. **Internal Salts on Servers or External Storage**: While not directly implemented within Spring Security, these salts are typically stored locally on the server or external storage (like USB) to prevent unauthorized decryption without proper key handling.

4. **JSP and SAX Event**: JPA's `sax` event is used for validation, allowing tokens to be validated when displayed on a page. This integration ensures token integrity during application execution.

5. **Custom Classes from API Providers**: Some providers like Spring Play might offer JWT-related classes that provide encryption handling through third-party libraries.

In summary, while Spring Security may not have an internal implementation of the JWT mechanism, it relies on external libraries and custom classes within its framework to handle token validation, encryption, and deserialization.
2025-06-14 22:14:51.599 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: <think>
Okay, so I'm trying to figure out how Spring Security implements the JWT token. I know that JWT stands for JavaScript-Short-lived Token, which is a way to secure tokens in web applications. But I'm not entirely sure about all the details, especially since Spring Security uses it with other libraries like Spring Web and Spring Security API.

First, I remember that JWT involves something called a salt.
2025-06-14 22:14:52.681 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: <think>
자, 이제 Spring Security가 JWT 토큰을 구현하는 방법을 알아내려고 합니다. JWT는 JavaScript-Short-lived Token의 약자로 웹 애플리케이션에서 토큰을 보호하는 방법입니다. 그러나 Spring Security는 Spring Web 및 Spring Security API와 같은 다른 라이브러리와 함께 사용하기 때문에 모든 세부 사항에 대해 완전히 확신하지 못합니다.

첫째, JWT는 소금이라는 것을 포함한다는 것을 기억합니다.
2025-06-14 22:14:52.682 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: From what I've heard before, the salt is a random string used along with the hash of the token to create each unique signature for the token. So maybe Spring Security uses a salt when handling tokens? But wait, does it use an internal salt stored on the server or external storage?

I think Spring Web provides some utility classes that handle JWT encryption and deserialization.
2025-06-14 22:14:53.490 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 이전에 들은 바에 따르면, SALT는 토큰의 해시와 함께 토큰에 대한 각 고유한 서명을 만드는 데 사용되는 임의의 문자열입니다. 그렇다면 Spring Security는 토큰을 처리할 때 SALT를 사용할까요? 하지만 잠깐, 서버 또는 외부 저장소에 저장된 내부 솔트를 사용합니까?

Spring Web은 JWT 암호화 및 역직렬화를 처리하는 몇 가지 유틸리티 클래스를 제공한다고 생각합니다.
2025-06-14 22:14:53.491 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: They have methods like encryptToken(), which probably takes the token and the key to hash, then applies the salt. Then there's decryptToken(), which would take the encrypted byte stream and return the original token and key.

But how does this integrate with Spring Security? I know Spring Web has a Token class that holds the token data, but maybe it uses something like Spring Sec or Spring Play for handling JWT specifically.
2025-06-14 22:14:54.259 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 그들은 encryptToken () 과 같은 메소드를 가지고 있는데, 아마도 토큰과 키를 해시에 취한 다음 솔트를 적용합니다. 그런 다음 암호화된 바이트 스트림을 가져와 원래 토큰과 키를 반환하는 decryptToken () 이 있습니다.

그러나 이것이 Spring Security와 어떻게 통합됩니까? Spring Web에는 토큰 데이터를 보유하는 토큰 클래스가 있지만 특히 JWT를 처리하기 위해 Spring Sec 또는 Spring Play와 같은 것을 사용할 수 있습니다.
2025-06-14 22:14:54.260 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Wait, did Spring Security use Spring Play as their API in a previous version? If so, Spring Play might handle token validation and encryption using custom classes.

I'm trying to recall if there's an encryption class in Spring Play that implements the JSPToken interface. If not, maybe they used different libraries or extensions.
2025-06-14 22:14:54.925 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 잠시만요, Spring Security가 이전 버전에서 Spring Play를 API로 사용했나요? 그렇다면 Spring Play는 사용자 정의 클래스를 사용하여 토큰 유효성 검사 및 암호화를 처리할 수 있습니다.

Spring Play에 JSPToken 인터페이스를 구현하는 암호화 클래스가 있는지 기억하려고 합니다. 그렇지 않은 경우 다른 라이브러리 또는 확장을 사용했을 수 있습니다.
2025-06-14 22:14:54.926 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: I think some people suggest using Spring Security's Play package with specific modules for JWT handling, but I'm not sure if that's still active or needed anymore.

I also remember that when dealing with tokens and security, especially in Spring, there might be some custom classes or plugins involved. Maybe they use the javax.xml module to handle token validation and encryption.
2025-06-14 22:14:55.649 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: JWT 처리를 위한 특정 모듈과 함께 Spring Security의 Play 패키지를 사용하는 것을 제안하는 사람들이 있다고 생각하지만, 여전히 활성화되어 있는지 또는 더 이상 필요한지 확실하지 않습니다.

또한 특히 Spring에서 토큰과 보안을 다룰 때 일부 사용자 정의 클래스 또는 플러그인이 관련되어 있을 수 있다는 것을 기억합니다. 토큰 유효성 검사 및 암호화를 처리하기 위해 javax.xml 모듈을 사용할 수 있습니다.
2025-06-14 22:14:55.649 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: That could mean that even if Spring Security doesn't have its own implementation of JWT, it relies on third-party XML-based libraries for token handling.

So putting it all together: Spring Security handles JWT tokens by possibly using internal salts in their classes or relying on external libraries like Play with XML modules to manage the token validation and encryption.
2025-06-14 22:14:56.365 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 이는 Spring Security가 자체 JWT 구현이 없더라도 토큰 처리를 위해 타사 XML 기반 라이브러리에 의존한다는 것을 의미할 수 있습니다.

그래서 모든 것을 합치면: Spring Security는 클래스에서 내부 솔트를 사용하거나 Play with XML 모듈과 같은 외부 라이브러리에 의존하여 토큰 유효성 검사 및 암호화를 관리함으로써 JWT 토큰을 처리합니다.
2025-06-14 22:14:56.365 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: They might also use custom classes from the Spring Security API or other providers if such implementations exist.

I think I need to verify this, but based on what I remember, Spring Security primarily relies on third-party libraries for handling JWT tokens in their application security layer.
</think>

Spring Security implements the JWT token through several mechanisms, which can be summarized as follows:

1.
2025-06-14 22:14:57.289 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 이러한 구현이 있는 경우 스프링 보안 API 또는 다른 공급자의 사용자 정의 클래스를 사용할 수도 있습니다.

이를 확인해야 할 것 같지만, 제가 기억하는 바에 따르면 Spring Security는 주로 애플리케이션 보안 계층에서 JWT 토큰을 처리하기 위해 타사 라이브러리에 의존합니다.
</think>

Spring Security는 다음과 같이 요약할 수 있는 몇 가지 메커니즘을 통해 JWT 토큰을 구현합니다.

1.
2025-06-14 22:14:57.290 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Salt Utilization**: The salt is a random string used with each token hash to create unique signatures. This ensures that even if two different tokens have the same hash (using a collision-resistant hashing algorithm like SHA-512), they will result in different JWT signatures.

2.
2025-06-14 22:14:57.945 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: * * 솔트 활용도 * *: 솔트는 고유한 서명을 생성하기 위해 각 토큰 해시와 함께 사용되는 임의의 문자열입니다. 이렇게 하면 두 개의 서로 다른 토큰이 동일한 해시를 가지더라도 (SHA-512와 같은 충돌 방지 해시 알고리즘 사용) 서로 다른 JWT 시그니처가 생성됩니다.

2.
2025-06-14 22:14:57.945 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Encryption and Decryption**: Spring Security uses Spring Play's `jsp` package, which includes classes implementing the `JSPToken` interface for handling token validation and encryption. These classes handle encryption using a custom class that applies the salt to each token before hashing.

3.
2025-06-14 22:14:58.615 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: * * 암호화 및 복호화 * *: Spring Security는 토큰 유효성 검사 및 암호화를 처리하기 위해 `JSPToken` 인터페이스를 구현하는 클래스를 포함하는 Spring Play의 `jsp' 패키지를 사용합니다. 이러한 클래스는 해시하기 전에 각 토큰에 솔트를 적용하는 사용자 정의 클래스를 사용하여 암호화를 처리합니다.

3.
2025-06-14 22:14:58.616 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Internal Salts on Servers or External Storage**: While not directly implemented within Spring Security, these salts are typically stored locally on the server or external storage (like USB) to prevent unauthorized decryption without proper key handling.

4. **JSP and SAX Event**: JPA's `sax` event is used for validation, allowing tokens to be validated when displayed on a page.
2025-06-14 22:14:59.338 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: * * 서버 또는 외부 저장소의 내부 솔트 * *: 스프링 시큐리티 내에서 직접 구현되지는 않지만, 이러한 솔트는 일반적으로 적절한 키 처리 없이 무단 복호화를 방지하기 위해 서버 또는 외부 저장소 (예: USB) 에 로컬로 저장됩니다.

4. * * JSP 및 SAX 이벤트 * *: JPA의 `SAX` 이벤트는 유효성 검사에 사용되므로 페이지에 표시될 때 토큰을 유효성 검사할 수 있습니다.
2025-06-14 22:14:59.339 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: This integration ensures token integrity during application execution.

5. **Custom Classes from API Providers**: Some providers like Spring Play might offer JWT-related classes that provide encryption handling through third-party libraries.
2025-06-14 22:14:59.985 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 이 통합은 애플리케이션 실행 중에 토큰 무결성을 보장합니다.

5. * * API 제공업체의 사용자 지정 클래스 * *: Spring Play와 같은 일부 제공업체는 타사 라이브러리를 통해 암호화 처리를 제공하는 JWT 관련 클래스를 제공할 수 있습니다.
2025-06-14 22:14:59.985 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: In summary, while Spring Security may not have an internal implementation of the JWT mechanism, it relies on external libraries and custom classes within its framework to handle token validation, encryption, and deserialization.
2025-06-14 22:15:00.635 [http-nio-8080-exec-1] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 요약하면, Spring Security는 JWT 메커니즘의 내부 구현을 가지고 있지 않을 수 있지만, 토큰 유효성 검사, 암호화 및 역직렬화를 처리하기 위해 프레임워크 내의 외부 라이브러리 및 사용자 정의 클래스에 의존합니다.
2025-06-14 22:15:00.635 [http-nio-8080-exec-1] DEBUG p.upik.shared.ai.service.AIService - DeepSeek AI response (translated to Korean): <think>
자, 이제 Spring Security가 JWT 토큰을 구현하는 방법을 알아내려고 합니다. JWT는 JavaScript-Short-lived Token의 약자로 웹 애플리케이션에서 토큰을 보호하는 방법입니다. 그러나 Spring Security는 Spring Web 및 Spring Security API와 같은 다른 라이브러리와 함께 사용하기 때문에 모든 세부 사항에 대해 완전히 확신하지 못합니다.

첫째, JWT는 소금이라는 것을 포함한다는 것을 기억합니다. 이전에 들은 바에 따르면, SALT는 토큰의 해시와 함께 토큰에 대한 각 고유한 서명을 만드는 데 사용되는 임의의 문자열입니다. 그렇다면 Spring Security는 토큰을 처리할 때 SALT를 사용할까요? 하지만 잠깐, 서버 또는 외부 저장소에 저장된 내부 솔트를 사용합니까?

Spring Web은 JWT 암호화 및 역직렬화를 처리하는 몇 가지 유틸리티 클래스를 제공한다고 생각합니다. 그들은 encryptToken () 과 같은 메소드를 가지고 있는데, 아마도 토큰과 키를 해시에 취한 다음 솔트를 적용합니다. 그런 다음 암호화된 바이트 스트림을 가져와 원래 토큰과 키를 반환하는 decryptToken () 이 있습니다.

그러나 이것이 Spring Security와 어떻게 통합됩니까? Spring Web에는 토큰 데이터를 보유하는 토큰 클래스가 있지만 특히 JWT를 처리하기 위해 Spring Sec 또는 Spring Play와 같은 것을 사용할 수 있습니다. 잠시만요, Spring Security가 이전 버전에서 Spring Play를 API로 사용했나요? 그렇다면 Spring Play는 사용자 정의 클래스를 사용하여 토큰 유효성 검사 및 암호화를 처리할 수 있습니다.

Spring Play에 JSPToken 인터페이스를 구현하는 암호화 클래스가 있는지 기억하려고 합니다. 그렇지 않은 경우 다른 라이브러리 또는 확장을 사용했을 수 있습니다. JWT 처리를 위한 특정 모듈과 함께 Spring Security의 Play 패키지를 사용하는 것을 제안하는 사람들이 있다고 생각하지만, 여전히 활성화되어 있는지 또는 더 이상 필요한지 확실하지 않습니다.

또한 특히 Spring에서 토큰과 보안을 다룰 때 일부 사용자 정의 클래스 또는 플러그인이 관련되어 있을 수 있다는 것을 기억합니다. 토큰 유효성 검사 및 암호화를 처리하기 위해 javax.xml 모듈을 사용할 수 있습니다. 이는 Spring Security가 자체 JWT 구현이 없더라도 토큰 처리를 위해 타사 XML 기반 라이브러리에 의존한다는 것을 의미할 수 있습니다.

그래서 모든 것을 합치면: Spring Security는 클래스에서 내부 솔트를 사용하거나 Play with XML 모듈과 같은 외부 라이브러리에 의존하여 토큰 유효성 검사 및 암호화를 관리함으로써 JWT 토큰을 처리합니다. 이러한 구현이 있는 경우 스프링 보안 API 또는 다른 공급자의 사용자 정의 클래스를 사용할 수도 있습니다.

이를 확인해야 할 것 같지만, 제가 기억하는 바에 따르면 Spring Security는 주로 애플리케이션 보안 계층에서 JWT 토큰을 처리하기 위해 타사 라이브러리에 의존합니다.
</think>

Spring Security는 다음과 같이 요약할 수 있는 몇 가지 메커니즘을 통해 JWT 토큰을 구현합니다.

1. * * 솔트 활용도 * *: 솔트는 고유한 서명을 생성하기 위해 각 토큰 해시와 함께 사용되는 임의의 문자열입니다. 이렇게 하면 두 개의 서로 다른 토큰이 동일한 해시를 가지더라도 (SHA-512와 같은 충돌 방지 해시 알고리즘 사용) 서로 다른 JWT 시그니처가 생성됩니다.

2. * * 암호화 및 복호화 * *: Spring Security는 토큰 유효성 검사 및 암호화를 처리하기 위해 `JSPToken` 인터페이스를 구현하는 클래스를 포함하는 Spring Play의 `jsp' 패키지를 사용합니다. 이러한 클래스는 해시하기 전에 각 토큰에 솔트를 적용하는 사용자 정의 클래스를 사용하여 암호화를 처리합니다.

3. * * 서버 또는 외부 저장소의 내부 솔트 * *: 스프링 시큐리티 내에서 직접 구현되지는 않지만, 이러한 솔트는 일반적으로 적절한 키 처리 없이 무단 복호화를 방지하기 위해 서버 또는 외부 저장소 (예: USB) 에 로컬로 저장됩니다.

4. * * JSP 및 SAX 이벤트 * *: JPA의 `SAX` 이벤트는 유효성 검사에 사용되므로 페이지에 표시될 때 토큰을 유효성 검사할 수 있습니다. 이 통합은 애플리케이션 실행 중에 토큰 무결성을 보장합니다.

5. * * API 제공업체의 사용자 지정 클래스 * *: Spring Play와 같은 일부 제공업체는 타사 라이브러리를 통해 암호화 처리를 제공하는 JWT 관련 클래스를 제공할 수 있습니다. 요약하면, Spring Security는 JWT 메커니즘의 내부 구현을 가지고 있지 않을 수 있지만, 토큰 유효성 검사, 암호화 및 역직렬화를 처리하기 위해 프레임워크 내의 외부 라이브러리 및 사용자 정의 클래스에 의존합니다.
2025-06-14 22:17:05.730 [SpringApplicationShutdownHook] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Commencing graceful shutdown. Waiting for active requests to complete
2025-06-14 22:17:05.737 [tomcat-shutdown] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Graceful shutdown complete
2025-06-14 22:17:05.753 [SpringApplicationShutdownHook] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Closing JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:17:05.759 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown initiated...
2025-06-14 22:17:05.801 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown completed.
2025-06-14 22:17:09.679 [background-preinit] INFO  o.h.validator.internal.util.Version - HV000001: Hibernate Validator 8.0.2.Final
2025-06-14 22:17:09.700 [main] INFO  pluto.upik.UpikApplication - Starting UpikApplication using Java 21.0.4 with PID 16609 (/Users/upik/build/classes/java/main started by heodongun in /Users/upik)
2025-06-14 22:17:09.700 [main] DEBUG pluto.upik.UpikApplication - Running with Spring Boot v3.5.0, Spring v6.2.7
2025-06-14 22:17:09.700 [main] INFO  pluto.upik.UpikApplication - No active profile set, falling back to 1 default profile: "default"
2025-06-14 22:17:10.141 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-06-14 22:17:10.211 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 66 ms. Found 5 JPA repository interfaces.
2025-06-14 22:17:10.498 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port 8080 (http)
2025-06-14 22:17:10.505 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2025-06-14 22:17:10.505 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-06-14 22:17:10.505 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.41]
2025-06-14 22:17:10.530 [main] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
2025-06-14 22:17:10.530 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 812 ms
2025-06-14 22:17:10.609 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
2025-06-14 22:17:11.863 [main] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection org.mariadb.jdbc.Connection@d66502
2025-06-14 22:17:11.866 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
2025-06-14 22:17:11.906 [main] INFO  o.h.jpa.internal.util.LogHelper - HHH000204: Processing PersistenceUnitInfo [name: default]
2025-06-14 22:17:11.942 [main] INFO  org.hibernate.Version - HHH000412: Hibernate ORM core version 6.6.15.Final
2025-06-14 22:17:11.958 [main] INFO  o.h.c.i.RegionFactoryInitiator - HHH000026: Second-level cache disabled
2025-06-14 22:17:12.102 [main] INFO  o.s.o.j.p.SpringPersistenceUnitInfo - No LoadTimeWeaver setup: ignoring JPA class transformer
2025-06-14 22:17:12.552 [main] INFO  o.hibernate.orm.connections.pooling - HHH10001005: Database info:
	Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
	Database driver: undefined/unknown
	Database version: 10.11.11
	Autocommit mode: undefined/unknown
	Isolation level: undefined/unknown
	Minimum pool size: undefined/unknown
	Maximum pool size: undefined/unknown
2025-06-14 22:17:13.035 [main] INFO  o.h.e.t.j.p.i.JtaPlatformInitiator - HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-06-14 22:17:13.036 [main] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:17:13.179 [main] INFO  o.s.d.j.r.query.QueryEnhancerFactory - Hibernate is in classpath; If applicable, HQL parser will be used.
2025-06-14 22:17:13.829 [main] WARN  o.s.b.a.o.j.JpaBaseConfiguration$JpaWebConfiguration - spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-06-14 22:17:14.353 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2025-06-14 22:17:14.358 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port 8080 (http) with context path '/'
2025-06-14 22:17:14.369 [main] INFO  pluto.upik.UpikApplication - Started UpikApplication in 4.931 seconds (process running for 5.399)
2025-06-14 22:17:18.420 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-06-14 22:17:18.420 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2025-06-14 22:17:18.423 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 3 ms
2025-06-14 22:17:18.927 [http-nio-8080-exec-9] INFO  o.s.api.AbstractOpenApiResource - Init duration for springdoc-openapi is: 234 ms
2025-06-14 22:17:23.667 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (original): 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 22:17:23.667 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 22:17:25.980 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: How does Spring Security implement the JWT token?
2025-06-14 22:17:25.980 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - Question to DeepSeek AI (translated to English): How does Spring Security implement the JWT token?
2025-06-14 22:18:05.901 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - Received DeepSeek AI response (English): <think>
Okay, so I'm trying to understand how Spring Security implements a JWT token. I remember that Spring Security is part of Spring Framework, which provides Java security solutions. They use different security libraries and components for various aspects of web applications.

First, I know that JWT (Token Type-JWT) stands for wrapping Token-based Authentication. It's used in API requests to authenticate users before granting access. So, the core idea is that each request gets a token, which can be checked against an attribute or parameter passed during authentication.

Now, Spring Security has built-in capabilities for handling tokens. I recall they have classes like WebTokenStorage. Let me think: WebTokenStorage is responsible for storing and managing tokens in the context. When you make a request, Spring Security should retrieve the token from this storage.

Wait, but how does it get there? I remember that each request has a token attribute. So, when a client makes an HTTP request to a service, they include something like Request.addAttribute("token", "value"). Then, when handling that request, Spring Security should check for this token.

I think the process goes like this: When a client sends a POST or GET request with a token attribute, it's stored in WebTokenStorage. Then, Spring Security would look into WebTokenStorage to retrieve and validate the token. If there's an associated JAR file from Spring Security, perhaps with its own token storage class?

Wait, I'm getting a bit confused. Let me try breaking it down step by step.

1. **Client Side Handling**: When a client makes a request that includes the "token" attribute, they include a string like "abc123".

2. **WebTokenStorage Retrieval**: The service where this token is stored (probably inside Spring's application context) will read the token from WebTokenStorage.

3. **Validation and Storage**: Once the token is retrieved, it needs to be validated against an attribute that's passed during authentication. If such an attribute exists, say "auth" or "id", and a JAR file with Spring Security's own token storage class (like AuthenticationTokenStorage) has been initialized, it can store the token into this class.

4. **Access Control**: The Spring Security component will then check if there's a corresponding "unfragging" attribute that indicates granting access. If so, it uses the token stored in the AuthenticationTokenStorage to perform authentication.

5. **Decryption and Response**: Finally, after decryption is successful, the response body is decrypted again using the original request headers (like Content-Type) before being sent back to the client.

But wait, how exactly are the tokens managed across multiple requests? Does each call use a new token, or do they share one per service session?

I think it's per request. Each request gets its own token because authentication is on-the-fly and not tied to a specific session for that particular API call. So, the same token can be used across different services as long as each context has its own WebTokenStorage instance.

Also, I remember that Spring Security might use some form of token wrapping, where tokens are stored in a repository or storage service so they don't get lost if the request is dropped or the container is shut down.

I'm not entirely sure about the specifics regarding how exactly the token is retrieved and validated. Maybe it involves some kind of serialization mechanism where the token is passed along with headers to ensure it's correct when received by the client.

Another thing: I think Spring Security might handle cases where a token from an earlier request is used in a later one, but that would require some form of persistence or re-authentication, which could be tricky. Perhaps Spring Security has mechanisms for that using its JAR classes?

Also, considering performance, how does the storage work? Is it done at the time of the request, or can multiple threads access and store the token from different parts of the application?

I'm trying to piece this together without having looked up all the details. So, in summary, Spring Security uses WebTokenStorage on the client side, retrieves the token, validates it against an attribute, stores it if needed using Spring's own token storage, and then uses that stored token for authentication.

But I might be missing some steps or details about how this is implemented, especially regarding serialization, persistence across requests, and handling different types of authentication attributes. It would also help to know if the authentication is performed immediately on receiving the token attribute or needs more processing.

I think a key point is that Spring Security's token management integrates with the application context's WebTokenStorage, ensuring that tokens are managed in a way that fits within the Spring architecture and leverages its existing infrastructure for security components.
</think>

Spring Security implements JWT tokens through its comprehensive security framework. Here's a structured overview of how it handles token implementation:

1. **Client Side Handling**: Clients include a "token" attribute (e.g., "abc123") in their HTTP request headers.

2. **WebTokenStorage Retrieval**: The application context, containing Spring's WebTokenStorage, reads the token from this storage upon receiving the request.

3. **Validation and Storage**: The retrieved token is validated against an authentication attribute (like "auth" or "id"). If present, it's stored in Spring Security's token storage class using its own AuthenticationTokenStorage instance.

4. **Access Control**: A corresponding "unfragging" attribute indicates granting access. Successful authentication uses the stored token for decryption and response processing.

5. **Decryption and Response**: After successful access control, the application decrypts the response body again with Content-Type headers before sending it back to the client.

6. **Token Persistence and Across Requests**: WebTokenStorage manages per-request tokens, ensuring each call gets a unique token unless specific conditions require re-authentication. Spring's design leverages its infrastructure for efficient token storage and retrieval across multiple requests.

This approach ensures robust security by integrating token management with Spring's architecture, providing secure components while managing authentication dynamically.
2025-06-14 22:18:05.902 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - AI response after removing think tags: <think>
Okay, so I'm trying to understand how Spring Security implements a JWT token. I remember that Spring Security is part of Spring Framework, which provides Java security solutions. They use different security libraries and components for various aspects of web applications.

First, I know that JWT (Token Type-JWT) stands for wrapping Token-based Authentication. It's used in API requests to authenticate users before granting access. So, the core idea is that each request gets a token, which can be checked against an attribute or parameter passed during authentication.

Now, Spring Security has built-in capabilities for handling tokens. I recall they have classes like WebTokenStorage. Let me think: WebTokenStorage is responsible for storing and managing tokens in the context. When you make a request, Spring Security should retrieve the token from this storage.

Wait, but how does it get there? I remember that each request has a token attribute. So, when a client makes an HTTP request to a service, they include something like Request.addAttribute("token", "value"). Then, when handling that request, Spring Security should check for this token.

I think the process goes like this: When a client sends a POST or GET request with a token attribute, it's stored in WebTokenStorage. Then, Spring Security would look into WebTokenStorage to retrieve and validate the token. If there's an associated JAR file from Spring Security, perhaps with its own token storage class?

Wait, I'm getting a bit confused. Let me try breaking it down step by step.

1. **Client Side Handling**: When a client makes a request that includes the "token" attribute, they include a string like "abc123".

2. **WebTokenStorage Retrieval**: The service where this token is stored (probably inside Spring's application context) will read the token from WebTokenStorage.

3. **Validation and Storage**: Once the token is retrieved, it needs to be validated against an attribute that's passed during authentication. If such an attribute exists, say "auth" or "id", and a JAR file with Spring Security's own token storage class (like AuthenticationTokenStorage) has been initialized, it can store the token into this class.

4. **Access Control**: The Spring Security component will then check if there's a corresponding "unfragging" attribute that indicates granting access. If so, it uses the token stored in the AuthenticationTokenStorage to perform authentication.

5. **Decryption and Response**: Finally, after decryption is successful, the response body is decrypted again using the original request headers (like Content-Type) before being sent back to the client.

But wait, how exactly are the tokens managed across multiple requests? Does each call use a new token, or do they share one per service session?

I think it's per request. Each request gets its own token because authentication is on-the-fly and not tied to a specific session for that particular API call. So, the same token can be used across different services as long as each context has its own WebTokenStorage instance.

Also, I remember that Spring Security might use some form of token wrapping, where tokens are stored in a repository or storage service so they don't get lost if the request is dropped or the container is shut down.

I'm not entirely sure about the specifics regarding how exactly the token is retrieved and validated. Maybe it involves some kind of serialization mechanism where the token is passed along with headers to ensure it's correct when received by the client.

Another thing: I think Spring Security might handle cases where a token from an earlier request is used in a later one, but that would require some form of persistence or re-authentication, which could be tricky. Perhaps Spring Security has mechanisms for that using its JAR classes?

Also, considering performance, how does the storage work? Is it done at the time of the request, or can multiple threads access and store the token from different parts of the application?

I'm trying to piece this together without having looked up all the details. So, in summary, Spring Security uses WebTokenStorage on the client side, retrieves the token, validates it against an attribute, stores it if needed using Spring's own token storage, and then uses that stored token for authentication.

But I might be missing some steps or details about how this is implemented, especially regarding serialization, persistence across requests, and handling different types of authentication attributes. It would also help to know if the authentication is performed immediately on receiving the token attribute or needs more processing.

I think a key point is that Spring Security's token management integrates with the application context's WebTokenStorage, ensuring that tokens are managed in a way that fits within the Spring architecture and leverages its existing infrastructure for security components.
</think>

Spring Security implements JWT tokens through its comprehensive security framework. Here's a structured overview of how it handles token implementation:

1. **Client Side Handling**: Clients include a "token" attribute (e.g., "abc123") in their HTTP request headers.

2. **WebTokenStorage Retrieval**: The application context, containing Spring's WebTokenStorage, reads the token from this storage upon receiving the request.

3. **Validation and Storage**: The retrieved token is validated against an authentication attribute (like "auth" or "id"). If present, it's stored in Spring Security's token storage class using its own AuthenticationTokenStorage instance.

4. **Access Control**: A corresponding "unfragging" attribute indicates granting access. Successful authentication uses the stored token for decryption and response processing.

5. **Decryption and Response**: After successful access control, the application decrypts the response body again with Content-Type headers before sending it back to the client.

6. **Token Persistence and Across Requests**: WebTokenStorage manages per-request tokens, ensuring each call gets a unique token unless specific conditions require re-authentication. Spring's design leverages its infrastructure for efficient token storage and retrieval across multiple requests.

This approach ensures robust security by integrating token management with Spring's architecture, providing secure components while managing authentication dynamically.
2025-06-14 22:18:05.903 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: <think>
Okay, so I'm trying to understand how Spring Security implements a JWT token. I remember that Spring Security is part of Spring Framework, which provides Java security solutions. They use different security libraries and components for various aspects of web applications.

First, I know that JWT (Token Type-JWT) stands for wrapping Token-based Authentication. It's used in API requests to authenticate users before granting access.
2025-06-14 22:18:07.930 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: <think>
자, 이제 Spring Security가 JWT 토큰을 구현하는 방법을 이해하려고 합니다. Spring Security는 Java 보안 솔루션을 제공하는 Spring Framework의 일부입니다. 웹 애플리케이션의 다양한 측면에 대해 서로 다른 보안 라이브러리 및 구성 요소를 사용합니다.

첫째, JWT (Token Type-JWT) 는 토큰 기반 인증을 래핑하는 것을 의미합니다. API 요청에서 액세스 권한을 부여하기 전에 사용자를 인증하는 데 사용됩니다.
2025-06-14 22:18:07.930 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: So, the core idea is that each request gets a token, which can be checked against an attribute or parameter passed during authentication.

Now, Spring Security has built-in capabilities for handling tokens. I recall they have classes like WebTokenStorage. Let me think: WebTokenStorage is responsible for storing and managing tokens in the context. When you make a request, Spring Security should retrieve the token from this storage.
2025-06-14 22:18:08.776 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 따라서 핵심 아이디어는 각 요청이 인증 중에 전달된 속성 또는 매개 변수에 대해 확인할 수 있는 토큰을 받는다는 것입니다.

이제 Spring Security에는 토큰을 처리할 수 있는 기능이 내장되어 있습니다. WebTokenStorage와 같은 클래스가 있는 것으로 기억합니다. 생각해 보겠습니다. WebTokenStorage는 컨텍스트에서 토큰을 저장하고 관리할 책임이 있습니다. 요청을 할 때 Spring Security는 이 스토리지에서 토큰을 검색해야 합니다.
2025-06-14 22:18:08.777 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Wait, but how does it get there? I remember that each request has a token attribute. So, when a client makes an HTTP request to a service, they include something like Request.addAttribute("token", "value"). Then, when handling that request, Spring Security should check for this token.

I think the process goes like this: When a client sends a POST or GET request with a token attribute, it's stored in WebTokenStorage.
2025-06-14 22:18:09.501 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 잠깐만요, 그런데 어떻게 되죠? 각 요청에는 토큰 속성이 있다는 것을 기억합니다. 따라서 클라이언트가 서비스에 HTTP 요청을 할 때 Request.addAttribute ("token", "value") 와 같은 것을 포함합니다. 그런 다음 해당 요청을 처리할 때 Spring Security는 이 토큰을 확인해야 합니다.

프로세스는 다음과 같이 진행됩니다. 클라이언트가 토큰 속성이 있는 POST를 보내거나 요청을 받으면 WebTokenStorage에 저장됩니다.
2025-06-14 22:18:09.501 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Then, Spring Security would look into WebTokenStorage to retrieve and validate the token. If there's an associated JAR file from Spring Security, perhaps with its own token storage class?

Wait, I'm getting a bit confused. Let me try breaking it down step by step.

1. **Client Side Handling**: When a client makes a request that includes the "token" attribute, they include a string like "abc123".

2.
2025-06-14 22:18:10.203 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 그런 다음 Spring Security는 WebTokenStorage를 조사하여 토큰을 검색하고 검증합니다. Spring Security의 관련 JAR 파일이 있는 경우 자체 토큰 스토리지 클래스가 있을 수 있습니다.

잠깐, 좀 헷갈리네. 차근차근 세분화해보겠습니다.

1. * * 클라이언트 측 처리 * *: 클라이언트가 "token" 속성을 포함하는 요청을 할 때 "abc123" 과 같은 문자열을 포함합니다.

2.
2025-06-14 22:18:10.204 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **WebTokenStorage Retrieval**: The service where this token is stored (probably inside Spring's application context) will read the token from WebTokenStorage.

3. **Validation and Storage**: Once the token is retrieved, it needs to be validated against an attribute that's passed during authentication.
2025-06-14 22:18:10.813 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: * * WebTokenStorage 검색 * *: 이 토큰이 저장된 서비스 (아마도 Spring의 응용 프로그램 컨텍스트 내부) 는 WebTokenStorage에서 토큰을 읽습니다.

3. * * 유효성 검사 및 저장 * *: 토큰이 검색되면 인증 중에 전달된 속성에 대해 유효성을 검사해야 합니다.
2025-06-14 22:18:10.813 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: If such an attribute exists, say "auth" or "id", and a JAR file with Spring Security's own token storage class (like AuthenticationTokenStorage) has been initialized, it can store the token into this class.

4. **Access Control**: The Spring Security component will then check if there's a corresponding "unfragging" attribute that indicates granting access.
2025-06-14 22:18:11.477 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 이러한 속성이 있는 경우 "auth" 또는 "id" 라고 말하고 Spring Security의 자체 토큰 스토리지 클래스 (AuthenticationTokenStorage 등) 가 있는 JAR 파일이 초기화되면 토큰을 이 클래스에 저장할 수 있습니다.

4. * * 액세스 제어 * *: 그러면 스프링 보안 구성 요소가 액세스 권한을 부여하는 것을 나타내는 해당 "언래깅" 속성이 있는지 확인합니다.
2025-06-14 22:18:11.477 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: If so, it uses the token stored in the AuthenticationTokenStorage to perform authentication.

5. **Decryption and Response**: Finally, after decryption is successful, the response body is decrypted again using the original request headers (like Content-Type) before being sent back to the client.

But wait, how exactly are the tokens managed across multiple requests? Does each call use a new token, or do they share one per service session?
2025-06-14 22:18:12.255 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 그렇다면 AuthenticationTokenStorage에 저장된 토큰을 사용하여 인증을 수행합니다.

5. * * 암호 해독 및 응답 * *: 마지막으로 암호 해독에 성공하면 응답 본문이 원래 요청 헤더 (예: 콘텐츠 유형) 를 사용하여 다시 암호 해독된 후 클라이언트로 다시 전송됩니다.

하지만 잠깐, 여러 요청에서 토큰은 정확히 어떻게 관리됩니까? 각 호출은 새로운 토큰을 사용합니까, 아니면 서비스 세션당 하나를 공유합니까?
2025-06-14 22:18:12.255 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: I think it's per request. Each request gets its own token because authentication is on-the-fly and not tied to a specific session for that particular API call. So, the same token can be used across different services as long as each context has its own WebTokenStorage instance.
2025-06-14 22:18:12.874 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 요청당이라고 생각합니다. 인증이 즉석에 있고 특정 API 호출에 대한 특정 세션에 연결되어 있지 않기 때문에 각 요청은 자체 토큰을 가져옵니다. 따라서 각 컨텍스트에 고유한 WebTokenStorage 인스턴스가 있는 한 동일한 토큰을 다른 서비스에서 사용할 수 있습니다.
2025-06-14 22:18:12.874 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Also, I remember that Spring Security might use some form of token wrapping, where tokens are stored in a repository or storage service so they don't get lost if the request is dropped or the container is shut down.

I'm not entirely sure about the specifics regarding how exactly the token is retrieved and validated.
2025-06-14 22:18:13.713 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 또한 Spring Security는 토큰이 저장소 또는 스토리지 서비스에 저장되어 요청이 삭제되거나 컨테이너가 종료될 때 손실되지 않도록 하는 일종의 토큰 래핑을 사용할 수 있습니다.

토큰이 정확히 어떻게 검색되고 검증되는지에 대한 구체적인 내용은 잘 모르겠습니다.
2025-06-14 22:18:13.714 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Maybe it involves some kind of serialization mechanism where the token is passed along with headers to ensure it's correct when received by the client.

Another thing: I think Spring Security might handle cases where a token from an earlier request is used in a later one, but that would require some form of persistence or re-authentication, which could be tricky. Perhaps Spring Security has mechanisms for that using its JAR classes?
2025-06-14 22:18:14.506 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 토큰이 클라이언트가 수신할 때 올바른지 확인하기 위해 헤더와 함께 전달되는 일종의 직렬화 메커니즘이 포함될 수 있습니다.

또 다른 것: 스프링 시큐리티가 이전 요청의 토큰이 나중에 사용되는 경우를 처리할 수 있다고 생각하지만, 이는 일종의 지속성 또는 재인증이 필요하며, 이는 까다로울 수 있습니다. Spring Security에는 JAR 클래스를 사용하는 메커니즘이 있습니까?
2025-06-14 22:18:14.506 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Also, considering performance, how does the storage work? Is it done at the time of the request, or can multiple threads access and store the token from different parts of the application?

I'm trying to piece this together without having looked up all the details.
2025-06-14 22:18:15.123 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 또한 성능을 고려할 때 스토리지가 어떻게 작동합니까? 요청 시 완료되었습니까? 아니면 여러 스레드가 애플리케이션의 다른 부분에서 토큰에 액세스하고 저장할 수 있습니까?

모든 세부 사항을 확인하지 않고 이것을 함께 정리하려고 합니다.
2025-06-14 22:18:15.123 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: So, in summary, Spring Security uses WebTokenStorage on the client side, retrieves the token, validates it against an attribute, stores it if needed using Spring's own token storage, and then uses that stored token for authentication.

But I might be missing some steps or details about how this is implemented, especially regarding serialization, persistence across requests, and handling different types of authentication attributes.
2025-06-14 22:18:15.784 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 요약하면, Spring Security는 클라이언트 측에서 WebTokenStorage를 사용하고, 토큰을 검색하고, 속성에 대해 유효성을 검사하고, Spring 자체 토큰 스토리지를 사용하여 필요한 경우 저장한 다음, 저장된 토큰을 인증에 사용합니다.

그러나 특히 직렬화, 요청 간 지속성 및 다양한 유형의 인증 속성 처리와 관련하여 이것이 구현되는 방법에 대한 몇 가지 단계 또는 세부 사항이 누락되었을 수 있습니다.
2025-06-14 22:18:15.784 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: It would also help to know if the authentication is performed immediately on receiving the token attribute or needs more processing.

I think a key point is that Spring Security's token management integrates with the application context's WebTokenStorage, ensuring that tokens are managed in a way that fits within the Spring architecture and leverages its existing infrastructure for security components.
2025-06-14 22:18:16.445 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 토큰 속성을 수신할 때 즉시 인증이 수행되는지 또는 더 많은 처리가 필요한지 여부를 아는 것도 도움이 될 것입니다.

중요한 점은 Spring Security의 토큰 관리가 애플리케이션 컨텍스트의 WebTokenStorage와 통합되어 Spring 아키텍처에 맞게 토큰을 관리하고 기존 인프라를 보안 구성 요소에 활용한다는 것입니다.
2025-06-14 22:18:16.445 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: </think>

Spring Security implements JWT tokens through its comprehensive security framework. Here's a structured overview of how it handles token implementation:

1. **Client Side Handling**: Clients include a "token" attribute (e.g., "abc123") in their HTTP request headers.

2. **WebTokenStorage Retrieval**: The application context, containing Spring's WebTokenStorage, reads the token from this storage upon receiving the request.

3.
2025-06-14 22:18:17.056 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: </think>

Spring Security는 포괄적인 보안 프레임워크를 통해 JWT 토큰을 구현합니다. 다음은 토큰 구현을 처리하는 방법에 대한 구조화된 개요입니다.

1. * * 클라이언트 측 처리 * *: 클라이언트는 HTTP 요청 헤더에 "토큰" 속성 (예: "abc123") 을 포함합니다.

2. * * WebTokenStorage 검색 * *: Spring의 WebTokenStorage가 포함된 애플리케이션 컨텍스트는 요청을 수신하면 이 스토리지에서 토큰을 읽습니다.

3.
2025-06-14 22:18:17.057 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Validation and Storage**: The retrieved token is validated against an authentication attribute (like "auth" or "id"). If present, it's stored in Spring Security's token storage class using its own AuthenticationTokenStorage instance.

4. **Access Control**: A corresponding "unfragging" attribute indicates granting access. Successful authentication uses the stored token for decryption and response processing.

5.
2025-06-14 22:18:17.765 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: * * 유효성 검사 및 저장 * *: 검색된 토큰은 인증 속성 (예: "auth" 또는 "id") 에 대해 유효성이 검사됩니다. 있는 경우 자체 AuthenticationTokenStorage 인스턴스를 사용하여 Spring Security의 토큰 스토리지 클래스에 저장됩니다.

4. * * 액세스 제어 * *: 해당 "언래깅" 속성은 액세스 권한을 부여함을 나타냅니다. 성공적인 인증은 암호 해독 및 응답 처리를 위해 저장된 토큰을 사용합니다.

5.
2025-06-14 22:18:17.765 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Decryption and Response**: After successful access control, the application decrypts the response body again with Content-Type headers before sending it back to the client.

6. **Token Persistence and Across Requests**: WebTokenStorage manages per-request tokens, ensuring each call gets a unique token unless specific conditions require re-authentication.
2025-06-14 22:18:18.395 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: * * 복호화 및 응답 * *: 액세스 제어가 성공하면 애플리케이션은 응답 본문을 다시 Content-Type 헤더로 복호화한 후 클라이언트에 다시 보냅니다.

6. * * 토큰 지속성 및 요청 간 * *: WebTokenStorage는 요청별 토큰을 관리하여 특정 조건이 재인증을 요구하지 않는 한 각 통화가 고유한 토큰을 받도록 합니다.
2025-06-14 22:18:18.395 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Spring's design leverages its infrastructure for efficient token storage and retrieval across multiple requests.

This approach ensures robust security by integrating token management with Spring's architecture, providing secure components while managing authentication dynamically.
2025-06-14 22:18:19.026 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 번역 완료: Spring의 설계는 여러 요청에서 효율적인 토큰 저장 및 검색을 위해 인프라를 활용합니다.

이 접근 방식은 토큰 관리를 Spring의 아키텍처와 통합하여 강력한 보안을 보장하고 인증을 동적으로 관리하면서 안전한 구성 요소를 제공합니다.
2025-06-14 22:18:19.027 [http-nio-8080-exec-10] DEBUG p.upik.shared.ai.service.AIService - DeepSeek AI response (translated to Korean): <think>
자, 이제 Spring Security가 JWT 토큰을 구현하는 방법을 이해하려고 합니다. Spring Security는 Java 보안 솔루션을 제공하는 Spring Framework의 일부입니다. 웹 애플리케이션의 다양한 측면에 대해 서로 다른 보안 라이브러리 및 구성 요소를 사용합니다.

첫째, JWT (Token Type-JWT) 는 토큰 기반 인증을 래핑하는 것을 의미합니다. API 요청에서 액세스 권한을 부여하기 전에 사용자를 인증하는 데 사용됩니다. 따라서 핵심 아이디어는 각 요청이 인증 중에 전달된 속성 또는 매개 변수에 대해 확인할 수 있는 토큰을 받는다는 것입니다.

이제 Spring Security에는 토큰을 처리할 수 있는 기능이 내장되어 있습니다. WebTokenStorage와 같은 클래스가 있는 것으로 기억합니다. 생각해 보겠습니다. WebTokenStorage는 컨텍스트에서 토큰을 저장하고 관리할 책임이 있습니다. 요청을 할 때 Spring Security는 이 스토리지에서 토큰을 검색해야 합니다. 잠깐만요, 그런데 어떻게 되죠? 각 요청에는 토큰 속성이 있다는 것을 기억합니다. 따라서 클라이언트가 서비스에 HTTP 요청을 할 때 Request.addAttribute ("token", "value") 와 같은 것을 포함합니다. 그런 다음 해당 요청을 처리할 때 Spring Security는 이 토큰을 확인해야 합니다.

프로세스는 다음과 같이 진행됩니다. 클라이언트가 토큰 속성이 있는 POST를 보내거나 요청을 받으면 WebTokenStorage에 저장됩니다. 그런 다음 Spring Security는 WebTokenStorage를 조사하여 토큰을 검색하고 검증합니다. Spring Security의 관련 JAR 파일이 있는 경우 자체 토큰 스토리지 클래스가 있을 수 있습니다.

잠깐, 좀 헷갈리네. 차근차근 세분화해보겠습니다.

1. * * 클라이언트 측 처리 * *: 클라이언트가 "token" 속성을 포함하는 요청을 할 때 "abc123" 과 같은 문자열을 포함합니다.

2. * * WebTokenStorage 검색 * *: 이 토큰이 저장된 서비스 (아마도 Spring의 응용 프로그램 컨텍스트 내부) 는 WebTokenStorage에서 토큰을 읽습니다.

3. * * 유효성 검사 및 저장 * *: 토큰이 검색되면 인증 중에 전달된 속성에 대해 유효성을 검사해야 합니다. 이러한 속성이 있는 경우 "auth" 또는 "id" 라고 말하고 Spring Security의 자체 토큰 스토리지 클래스 (AuthenticationTokenStorage 등) 가 있는 JAR 파일이 초기화되면 토큰을 이 클래스에 저장할 수 있습니다.

4. * * 액세스 제어 * *: 그러면 스프링 보안 구성 요소가 액세스 권한을 부여하는 것을 나타내는 해당 "언래깅" 속성이 있는지 확인합니다. 그렇다면 AuthenticationTokenStorage에 저장된 토큰을 사용하여 인증을 수행합니다.

5. * * 암호 해독 및 응답 * *: 마지막으로 암호 해독에 성공하면 응답 본문이 원래 요청 헤더 (예: 콘텐츠 유형) 를 사용하여 다시 암호 해독된 후 클라이언트로 다시 전송됩니다.

하지만 잠깐, 여러 요청에서 토큰은 정확히 어떻게 관리됩니까? 각 호출은 새로운 토큰을 사용합니까, 아니면 서비스 세션당 하나를 공유합니까? 요청당이라고 생각합니다. 인증이 즉석에 있고 특정 API 호출에 대한 특정 세션에 연결되어 있지 않기 때문에 각 요청은 자체 토큰을 가져옵니다. 따라서 각 컨텍스트에 고유한 WebTokenStorage 인스턴스가 있는 한 동일한 토큰을 다른 서비스에서 사용할 수 있습니다. 또한 Spring Security는 토큰이 저장소 또는 스토리지 서비스에 저장되어 요청이 삭제되거나 컨테이너가 종료될 때 손실되지 않도록 하는 일종의 토큰 래핑을 사용할 수 있습니다.

토큰이 정확히 어떻게 검색되고 검증되는지에 대한 구체적인 내용은 잘 모르겠습니다. 토큰이 클라이언트가 수신할 때 올바른지 확인하기 위해 헤더와 함께 전달되는 일종의 직렬화 메커니즘이 포함될 수 있습니다.

또 다른 것: 스프링 시큐리티가 이전 요청의 토큰이 나중에 사용되는 경우를 처리할 수 있다고 생각하지만, 이는 일종의 지속성 또는 재인증이 필요하며, 이는 까다로울 수 있습니다. Spring Security에는 JAR 클래스를 사용하는 메커니즘이 있습니까? 또한 성능을 고려할 때 스토리지가 어떻게 작동합니까? 요청 시 완료되었습니까? 아니면 여러 스레드가 애플리케이션의 다른 부분에서 토큰에 액세스하고 저장할 수 있습니까?

모든 세부 사항을 확인하지 않고 이것을 함께 정리하려고 합니다. 요약하면, Spring Security는 클라이언트 측에서 WebTokenStorage를 사용하고, 토큰을 검색하고, 속성에 대해 유효성을 검사하고, Spring 자체 토큰 스토리지를 사용하여 필요한 경우 저장한 다음, 저장된 토큰을 인증에 사용합니다.

그러나 특히 직렬화, 요청 간 지속성 및 다양한 유형의 인증 속성 처리와 관련하여 이것이 구현되는 방법에 대한 몇 가지 단계 또는 세부 사항이 누락되었을 수 있습니다. 토큰 속성을 수신할 때 즉시 인증이 수행되는지 또는 더 많은 처리가 필요한지 여부를 아는 것도 도움이 될 것입니다.

중요한 점은 Spring Security의 토큰 관리가 애플리케이션 컨텍스트의 WebTokenStorage와 통합되어 Spring 아키텍처에 맞게 토큰을 관리하고 기존 인프라를 보안 구성 요소에 활용한다는 것입니다. </think>

Spring Security는 포괄적인 보안 프레임워크를 통해 JWT 토큰을 구현합니다. 다음은 토큰 구현을 처리하는 방법에 대한 구조화된 개요입니다.

1. * * 클라이언트 측 처리 * *: 클라이언트는 HTTP 요청 헤더에 "토큰" 속성 (예: "abc123") 을 포함합니다.

2. * * WebTokenStorage 검색 * *: Spring의 WebTokenStorage가 포함된 애플리케이션 컨텍스트는 요청을 수신하면 이 스토리지에서 토큰을 읽습니다.

3. * * 유효성 검사 및 저장 * *: 검색된 토큰은 인증 속성 (예: "auth" 또는 "id") 에 대해 유효성이 검사됩니다. 있는 경우 자체 AuthenticationTokenStorage 인스턴스를 사용하여 Spring Security의 토큰 스토리지 클래스에 저장됩니다.

4. * * 액세스 제어 * *: 해당 "언래깅" 속성은 액세스 권한을 부여함을 나타냅니다. 성공적인 인증은 암호 해독 및 응답 처리를 위해 저장된 토큰을 사용합니다.

5. * * 복호화 및 응답 * *: 액세스 제어가 성공하면 애플리케이션은 응답 본문을 다시 Content-Type 헤더로 복호화한 후 클라이언트에 다시 보냅니다.

6. * * 토큰 지속성 및 요청 간 * *: WebTokenStorage는 요청별 토큰을 관리하여 특정 조건이 재인증을 요구하지 않는 한 각 통화가 고유한 토큰을 받도록 합니다. Spring의 설계는 여러 요청에서 효율적인 토큰 저장 및 검색을 위해 인프라를 활용합니다.

이 접근 방식은 토큰 관리를 Spring의 아키텍처와 통합하여 강력한 보안을 보장하고 인증을 동적으로 관리하면서 안전한 구성 요소를 제공합니다.
2025-06-14 22:22:37.964 [SpringApplicationShutdownHook] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Commencing graceful shutdown. Waiting for active requests to complete
2025-06-14 22:22:38.015 [tomcat-shutdown] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Graceful shutdown complete
2025-06-14 22:22:38.060 [SpringApplicationShutdownHook] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Closing JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:22:38.069 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown initiated...
2025-06-14 22:22:38.114 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown completed.
2025-06-14 22:22:43.081 [background-preinit] INFO  o.h.validator.internal.util.Version - HV000001: Hibernate Validator 8.0.2.Final
2025-06-14 22:22:43.103 [main] INFO  pluto.upik.UpikApplication - Starting UpikApplication using Java 21.0.4 with PID 16806 (/Users/upik/build/classes/java/main started by heodongun in /Users/upik)
2025-06-14 22:22:43.103 [main] DEBUG pluto.upik.UpikApplication - Running with Spring Boot v3.5.0, Spring v6.2.7
2025-06-14 22:22:43.104 [main] INFO  pluto.upik.UpikApplication - No active profile set, falling back to 1 default profile: "default"
2025-06-14 22:22:43.595 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-06-14 22:22:43.676 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 74 ms. Found 5 JPA repository interfaces.
2025-06-14 22:22:44.132 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port 8080 (http)
2025-06-14 22:22:44.139 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2025-06-14 22:22:44.140 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-06-14 22:22:44.140 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.41]
2025-06-14 22:22:44.170 [main] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
2025-06-14 22:22:44.170 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 1048 ms
2025-06-14 22:22:44.240 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
2025-06-14 22:22:45.568 [main] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection org.mariadb.jdbc.Connection@144a5e6e
2025-06-14 22:22:45.573 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
2025-06-14 22:22:45.626 [main] INFO  o.h.jpa.internal.util.LogHelper - HHH000204: Processing PersistenceUnitInfo [name: default]
2025-06-14 22:22:45.661 [main] INFO  org.hibernate.Version - HHH000412: Hibernate ORM core version 6.6.15.Final
2025-06-14 22:22:45.677 [main] INFO  o.h.c.i.RegionFactoryInitiator - HHH000026: Second-level cache disabled
2025-06-14 22:22:45.838 [main] INFO  o.s.o.j.p.SpringPersistenceUnitInfo - No LoadTimeWeaver setup: ignoring JPA class transformer
2025-06-14 22:22:46.303 [main] INFO  o.hibernate.orm.connections.pooling - HHH10001005: Database info:
	Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
	Database driver: undefined/unknown
	Database version: 10.11.11
	Autocommit mode: undefined/unknown
	Isolation level: undefined/unknown
	Minimum pool size: undefined/unknown
	Maximum pool size: undefined/unknown
2025-06-14 22:22:46.780 [main] INFO  o.h.e.t.j.p.i.JtaPlatformInitiator - HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-06-14 22:22:46.782 [main] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:22:46.929 [main] INFO  o.s.d.j.r.query.QueryEnhancerFactory - Hibernate is in classpath; If applicable, HQL parser will be used.
2025-06-14 22:22:47.376 [main] WARN  o.s.b.a.o.j.JpaBaseConfiguration$JpaWebConfiguration - spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-06-14 22:22:47.785 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2025-06-14 22:22:47.791 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port 8080 (http) with context path '/'
2025-06-14 22:22:47.799 [main] INFO  pluto.upik.UpikApplication - Started UpikApplication in 4.948 seconds (process running for 5.351)
2025-06-14 22:22:47.912 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-06-14 22:22:47.912 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2025-06-14 22:22:47.913 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 1 ms
2025-06-14 22:22:48.376 [http-nio-8080-exec-9] INFO  o.s.api.AbstractOpenApiResource - Init duration for springdoc-openapi is: 245 ms
2025-06-14 22:22:52.632 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 22:22:54.648 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: How does Spring Security implement the JWT token?
2025-06-14 22:23:25.824 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: <think>
Okay, so I'm trying to understand how Spring Security implements a JWT token. I remember that JWTs are used for storing secure credentials like authentication tokens, but I'm not exactly sure how Spring Security handles them. Let me break this down.

First off, what is a JWT? From what I know, a Tokenjugated Object (TO) uses a combination of an ExpiredAt and a CreationAt to create a token.
2025-06-14 22:23:27.740 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: <think>
자, 이제 Spring Security가 JWT 토큰을 구현하는 방법을 이해하려고 합니다. JWT는 인증 토큰과 같은 보안 자격 증명을 저장하는 데 사용되지만 Spring Security가 이를 어떻게 처리하는지 정확히 알지 못합니다. 좀 더 자세히 살펴보겠습니다.

먼저, JWT란 무엇인가요? 제가 아는 바로는, Tokenjugated Object (TO) 는 ExpiredAt와 CreationAt의 조합을 사용하여 토큰을 생성합니다.
2025-06-14 22:23:27.740 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: The creation time determines when the token expires. So, each token has these two timestamps that set its validity period.

Now, Spring Security probably has some integration with JPA because it's built on top of Java's security features. I think they might use Spring Data for serialization, which makes sense since JPA operations are typically handled through JDBC drivers or adapters.
2025-06-14 22:23:28.564 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 생성 시간은 토큰이 만료되는 시기를 결정합니다. 따라서 각 토큰에는 유효 기간을 설정하는 두 개의 타임스탬프가 있습니다.

이제 Spring Security는 Java의 보안 기능을 기반으로 하기 때문에 JPA와 어느 정도 통합되어 있을 것입니다. JPA 작업은 일반적으로 JDBC 드라이버 또는 어댑터를 통해 처리되기 때문에 직렬화를 위해 스프링 데이터를 사용할 수 있다고 생각합니다.
2025-06-14 22:23:28.564 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: So maybe they store the token data as a String in Spring Data.

Wait, but how do they store this? If each token is stored as a string with timestamps at both creation and expiration times, that seems straightforward. But I'm not sure if that's the standard approach or if there are better practices.

Then, to retrieve the token from Spring Data, they might use JPA operations like getTokenAsString(). That would fetch the token based on its ID.
2025-06-14 22:23:29.293 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 따라서 스프링 데이터에 토큰 데이터를 문자열로 저장할 수 있습니다.

잠깐만요, 그런데 이걸 어떻게 보관하나요? 각 토큰이 생성 및 만료 시간에 타임스탬프가 있는 문자열로 저장되면 간단해 보입니다. 하지만 그것이 표준 접근 방식인지 아니면 더 나은 관행이 있는지 확실하지 않습니다.

그런 다음 Spring Data에서 토큰을 검색하기 위해 getTokenAsString () 과 같은 JPA 작업을 사용할 수 있습니다. 그러면 ID를 기반으로 토큰을 가져옵니다.
2025-06-14 22:23:29.294 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: But how does Spring Security handle the timestamps? Maybe they store them as fields in the TO, like a private String for CreationAt and an int or long for ExpiredAt.

I'm also thinking about encryption. Since tokens are sensitive, they probably need to be encrypted using a symmetric cipher like AES. So, I suppose Spring Security would have a secure storage provider that handles this encryption.
2025-06-14 22:23:30.281 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 그러나 Spring Security는 타임 스탬프를 어떻게 처리합니까? CreationAt의 private String 및 ExpiredAt의 int 또는 long과 같이 TO에 필드로 저장할 수 있습니다.

암호화에 대해서도 생각하고 있습니다. 토큰은 민감하기 때문에 AES와 같은 대칭 암호를 사용하여 암호화해야 할 수 있습니다. 따라서 Spring Security에는 이 암호화를 처리하는 보안 스토리지 공급자가 있을 것입니다.
2025-06-14 22:23:30.282 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: They might store the encrypted token in Spring Data but then decrypt it when needed at runtime.

Another thing I'm considering is how they handle credentials. If someone needs to get the username and password from the token, maybe Spring Security uses a database schema or some configuration file. So, it's not just about storing the token itself but also how to retrieve those fields from somewhere else.
2025-06-14 22:23:31.024 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 암호화된 토큰을 스프링 데이터에 저장한 다음 런타임에 필요할 때 암호를 해독할 수 있습니다.

제가 고려하고 있는 또 다른 사항은 그들이 자격 증명을 처리하는 방법입니다. 누군가가 토큰에서 사용자 이름과 암호를 가져와야 하는 경우 Spring Security는 데이터베이스 스키마 또는 일부 구성 파일을 사용할 수 있습니다. 따라서 토큰 자체를 저장하는 것뿐만 아니라 다른 곳에서 해당 필드를 검색하는 방법도 중요합니다.
2025-06-14 22:23:31.025 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: I'm wondering about the lifecycle of the TO. How often does it need to be updated? Since each token expires after a certain period, once the ExpiredAt time is reached, the token should be rolled over. That would mean Spring Security has some mechanism for that. Maybe there's an event or listener in JPA that triggers on the expiration date.

Also, I'm thinking about security best practices here.
2025-06-14 22:23:31.674 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: TO의 수명 주기가 궁금합니다. 얼마나 자주 업데이트해야 하나요? 각 토큰은 특정 기간이 지나면 만료되므로 만료 시간에 도달하면 토큰을 롤오버해야 합니다. 이는 스프링 시큐리티가 이를 위한 메커니즘을 가지고 있음을 의미합니다. JPA에 만료일에 트리거되는 이벤트 또는 리스너가 있을 수 있습니다.

또한 여기에서 보안 모범 사례에 대해 생각하고 있습니다.
2025-06-14 22:23:31.675 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Storing passwords as raw strings can pose security risks if they're not properly secured. So, maybe Spring Security uses a secure storage provider to handle encryption and hashing, ensuring that even if the database is compromised, the stored data remains safe.

Putting this all together, it seems like Spring Security stores each token in Spring Data with timestamps for creation and expiration.
2025-06-14 22:23:32.353 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 암호를 원시 문자열로 저장하면 암호가 제대로 보호되지 않으면 보안 위험이 발생할 수 있습니다. 따라서 Spring Security는 암호화 및 해시를 처리하기 위해 보안 스토리지 공급자를 사용하여 데이터베이스가 손상되더라도 저장된 데이터가 안전하게 유지되도록 할 수 있습니다.

이 모든 것을 종합하면 Spring Security는 생성 및 만료에 대한 타임 스탬프와 함께 각 토큰을 Spring Data에 저장하는 것 같습니다.
2025-06-14 22:23:32.354 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: It retrieves them using JPA's getTokenAsString(), encrypts them when they're created or when retrieved, and updates the storage as needed to ensure tokens are valid until their ExpiredAt date.

I'm also curious about any customizations or specific providers used by Spring Security. Perhaps they use a custom secure storage provider for additional security features beyond just encryption.
2025-06-14 22:23:33.026 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: JPA의 getTokenAsString () 을 사용하여 토큰을 검색하고, 생성 시 또는 검색 시 암호화하고, 필요에 따라 저장소를 업데이트하여 토큰이 만료 날짜까지 유효하도록 합니다.

Spring Security에서 사용하는 맞춤 설정이나 특정 제공업체에 대해서도 궁금합니다. 암호화 이외의 추가 보안 기능을 위해 맞춤형 보안 스토리지 공급자를 사용할 수 있습니다.
2025-06-14 22:23:33.026 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: They might handle token rotation or some form of persistence that ensures only one instance exists at a time, preventing multiple users from having the same token.

In summary, Spring Security probably implements the JWT token by storing it in Spring Data with timestamps, encrypting and decrypting based on usage requirements, using secure storage for encryption, and managing token expiration through JPA events.
2025-06-14 22:23:33.743 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 번역 완료: 한 번에 하나의 인스턴스만 존재하도록 보장하여 여러 사용자가 동일한 토큰을 보유하는 것을 방지하는 토큰 회전 또는 일종의 지속성을 처리할 수 있습니다.

요약하면, Spring Security는 아마도 JWT 토큰을 타임 스탬프로 Spring Data에 저장하고, 사용 요구 사항에 따라 암호화 및 해독하고, 암호화를 위한 보안 스토리지를 사용하고, JPA 이벤트를 통해 토큰 만료를 관리함으로써 구현할 것입니다.
2025-06-14 22:23:33.744 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: It also handles credentials extraction from configurations or database schemas.
</think>

Spring Security implements a Tokenjugated Object (TO) to handle JWT tokens by following these steps:

1. **Storage in Spring Data**: Each TO stores the token data as a String within Spring Data, including timestamps for creation and expiration times.

2. **Retrieve Token**: Use JPA's `getTokenAsString()` method to fetch the stored token based on its ID.

3.
2025-06-14 22:23:34.062 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 36 MINUTES 27 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 36 MINUTES 27 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:83)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:113)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:23:34.069 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Encryption Handling**: Encrypt the token using a symmetric cipher (e.g., AES) when created or retrieved, ensuring security.

4. **Secure Storage**: Spring Security uses a secure storage provider to handle encryption and decryption, managing tokens for safe retrieval from databases.

5. **Credential Extraction**: Retrieve credentials like username and password through specific fields in the database schema or configuration files.

6.
2025-06-14 22:23:34.382 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 36 MINUTES 26 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 36 MINUTES 26 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:83)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:113)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:23:34.384 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Expiration Management**: Implement expiration logic with JPA events to roll over tokens when their ExpiredAt time reaches a certain date.

7. **Rotation and Persistence**: Use custom providers for token rotation and ensure persistence without multiple instances, enhancing security.

This implementation ensures secure, encrypted storage of JWT tokens that are valid until their expiration, managing user sessions securely.
2025-06-14 22:23:34.691 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 36 MINUTES 26 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 36 MINUTES 26 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:83)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:113)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:26:01.291 [SpringApplicationShutdownHook] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Commencing graceful shutdown. Waiting for active requests to complete
2025-06-14 22:26:01.311 [tomcat-shutdown] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Graceful shutdown complete
2025-06-14 22:26:01.321 [SpringApplicationShutdownHook] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Closing JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:26:01.324 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown initiated...
2025-06-14 22:26:01.376 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown completed.
2025-06-14 22:26:04.872 [background-preinit] INFO  o.h.validator.internal.util.Version - HV000001: Hibernate Validator 8.0.2.Final
2025-06-14 22:26:04.899 [main] INFO  pluto.upik.UpikApplication - Starting UpikApplication using Java 21.0.4 with PID 16848 (/Users/upik/build/classes/java/main started by heodongun in /Users/upik)
2025-06-14 22:26:04.900 [main] DEBUG pluto.upik.UpikApplication - Running with Spring Boot v3.5.0, Spring v6.2.7
2025-06-14 22:26:04.900 [main] INFO  pluto.upik.UpikApplication - No active profile set, falling back to 1 default profile: "default"
2025-06-14 22:26:05.349 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-06-14 22:26:05.427 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 72 ms. Found 5 JPA repository interfaces.
2025-06-14 22:26:05.677 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port 8080 (http)
2025-06-14 22:26:05.683 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2025-06-14 22:26:05.684 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-06-14 22:26:05.684 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.41]
2025-06-14 22:26:05.708 [main] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
2025-06-14 22:26:05.709 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 791 ms
2025-06-14 22:26:05.772 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
2025-06-14 22:26:07.271 [main] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection org.mariadb.jdbc.Connection@144a5e6e
2025-06-14 22:26:07.273 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
2025-06-14 22:26:07.305 [main] INFO  o.h.jpa.internal.util.LogHelper - HHH000204: Processing PersistenceUnitInfo [name: default]
2025-06-14 22:26:07.342 [main] INFO  org.hibernate.Version - HHH000412: Hibernate ORM core version 6.6.15.Final
2025-06-14 22:26:07.359 [main] INFO  o.h.c.i.RegionFactoryInitiator - HHH000026: Second-level cache disabled
2025-06-14 22:26:07.539 [main] INFO  o.s.o.j.p.SpringPersistenceUnitInfo - No LoadTimeWeaver setup: ignoring JPA class transformer
2025-06-14 22:26:08.006 [main] INFO  o.hibernate.orm.connections.pooling - HHH10001005: Database info:
	Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
	Database driver: undefined/unknown
	Database version: 10.11.11
	Autocommit mode: undefined/unknown
	Isolation level: undefined/unknown
	Minimum pool size: undefined/unknown
	Maximum pool size: undefined/unknown
2025-06-14 22:26:08.538 [main] INFO  o.h.e.t.j.p.i.JtaPlatformInitiator - HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-06-14 22:26:08.540 [main] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:26:08.687 [main] INFO  o.s.d.j.r.query.QueryEnhancerFactory - Hibernate is in classpath; If applicable, HQL parser will be used.
2025-06-14 22:26:09.144 [main] WARN  o.s.b.a.o.j.JpaBaseConfiguration$JpaWebConfiguration - spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-06-14 22:26:09.585 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2025-06-14 22:26:09.591 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port 8080 (http) with context path '/'
2025-06-14 22:26:09.599 [main] INFO  pluto.upik.UpikApplication - Started UpikApplication in 4.967 seconds (process running for 5.366)
2025-06-14 22:26:09.933 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-06-14 22:26:09.933 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2025-06-14 22:26:09.934 [http-nio-8080-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 1 ms
2025-06-14 22:26:10.346 [http-nio-8080-exec-9] INFO  o.s.api.AbstractOpenApiResource - Init duration for springdoc-openapi is: 210 ms
2025-06-14 22:26:34.624 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: 스프링 시큐리티에서 JWT 토큰을 어떻게 구현하나요?
2025-06-14 22:26:36.140 [http-nio-8080-exec-10] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 33 MINUTES 24 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 33 MINUTES 24 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateKoreanToEnglish(TranslationService.java:35)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:83)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:93)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:27:03.196 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: 스프tring 시큐리티에서 JWT 토큰 implementation에 대해 understand하고 wanna implement doofer, 下面有几个步骤可以参考：

### 1. **Import Necessary Libraries**
   - First，import一些必要的库。通常会用到`w3rd.js`（Node.js Web API）和`jsproto`（JSON 数据传递）。

```javascript
const w3rd = require('w3rd.js');
const jsProto = require('jsproto');
```

### 2.
2025-06-14 22:27:03.552 [http-nio-8080-exec-10] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:27:03.584 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Define JSON Format**
   - 定义你想要上传的JSON对象。JSON格式通常包含你的Token信息，如 expirationTime、Algorithm 和 Content-Type（通常为 application/json）。

```javascript
const data = {
  // Token info
  { type: 'token', id: '123' },
  // Token algorithm
  algorithm: 'seal-with-6b-v2',
  // Token content
  content: {
    { type: 'content', value: {
      "key": "your key"
    }}
  }
};
```

### 3.
2025-06-14 22:27:03.898 [http-nio-8080-exec-10] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:27:03.899 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Create a Token object**
   - 然后创建一个Token对象，包含需要上传的JSON数据。

```javascript
const token = w3rd.createToken(data);
```

### 4. **Generate JWT String**
   - 接下来，生成JWT字符串。JWT通常包括 expirationTime 和 Content.

```javascript
w3rd.createTokenForAuth(token, { type: 'token' }, data);
w3rd.createJWTString('token', token);
const jwt = w3rd.tokenFromJWT(w3rd JWTString, 'content');
```

### 5.
2025-06-14 22:27:03.899 [http-nio-8080-exec-10] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
java.lang.IllegalArgumentException: Not enough variable values available to expand ' type'
	at org.springframework.web.util.UriComponents$VarArgsTemplateVariables.getValue(UriComponents.java:370)
	at org.springframework.web.util.HierarchicalUriComponents$QueryUriTemplateVariables.getValue(HierarchicalUriComponents.java:1098)
	at org.springframework.web.util.UriComponents.expandUriComponent(UriComponents.java:263)
	at org.springframework.web.util.HierarchicalUriComponents.lambda$expandQueryParams$6(HierarchicalUriComponents.java:456)
	at org.springframework.util.UnmodifiableMultiValueMap.lambda$forEach$0(UnmodifiableMultiValueMap.java:115)
	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:986)
	at org.springframework.util.MultiValueMapAdapter.forEach(MultiValueMapAdapter.java:179)
	at org.springframework.util.UnmodifiableMultiValueMap.forEach(UnmodifiableMultiValueMap.java:115)
	at org.springframework.web.util.HierarchicalUriComponents.expandQueryParams(HierarchicalUriComponents.java:452)
	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:441)
	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:53)
	at org.springframework.web.util.UriComponents.expand(UriComponents.java:172)
	at org.springframework.web.util.DefaultUriBuilderFactory$DefaultUriBuilder.build(DefaultUriBuilderFactory.java:459)
	at pluto.upik.shared.translation.service.TranslationService.lambda$translate$0(TranslationService.java:75)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.uri(DefaultRestClient.java:336)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.uri(DefaultRestClient.java:287)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:71)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:27:03.900 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Generate Token Header**
   - 然后生成TokenHeader对象。

```javascript
const tokenHeader = w3rd.createTokenHeader(token);
w3rd.tokenHeaderToJSONArray(tokenHeader);
```

### 6. **Register Token in Web Application**
   - 最后，将JWT字符串注册到你的Web 应用程序中，并在需要时发送给客户端。

```javascript
// Register JWT string to your web app.
const webApp = w3rd.createWebApp();
webApp.registerTokenJWT(wt, jwt);

// Send the token to client.
2025-06-14 22:27:04.316 [http-nio-8080-exec-10] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:27:04.317 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: const { data } = webApp.get('http://localhost:8000/api');
```

### 7.
2025-06-14 22:27:04.317 [http-nio-8080-exec-10] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
java.lang.IllegalArgumentException: Not enough variable values available to expand ' data '
	at org.springframework.web.util.UriComponents$VarArgsTemplateVariables.getValue(UriComponents.java:370)
	at org.springframework.web.util.HierarchicalUriComponents$QueryUriTemplateVariables.getValue(HierarchicalUriComponents.java:1098)
	at org.springframework.web.util.UriComponents.expandUriComponent(UriComponents.java:263)
	at org.springframework.web.util.HierarchicalUriComponents.lambda$expandQueryParams$6(HierarchicalUriComponents.java:456)
	at org.springframework.util.UnmodifiableMultiValueMap.lambda$forEach$0(UnmodifiableMultiValueMap.java:115)
	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:986)
	at org.springframework.util.MultiValueMapAdapter.forEach(MultiValueMapAdapter.java:179)
	at org.springframework.util.UnmodifiableMultiValueMap.forEach(UnmodifiableMultiValueMap.java:115)
	at org.springframework.web.util.HierarchicalUriComponents.expandQueryParams(HierarchicalUriComponents.java:452)
	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:441)
	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:53)
	at org.springframework.web.util.UriComponents.expand(UriComponents.java:172)
	at org.springframework.web.util.DefaultUriBuilderFactory$DefaultUriBuilder.build(DefaultUriBuilderFactory.java:459)
	at pluto.upik.shared.translation.service.TranslationService.lambda$translate$0(TranslationService.java:75)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.uri(DefaultRestClient.java:336)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.uri(DefaultRestClient.java:287)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:71)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:27:04.317 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Sign and Sign Back JWT**
   - 如果需要更高级的签名功能，可以使用 `seal` 命令符。

```javascript
w3rd.createTokenForAuth(token, { type: 'token' }, data);
w3rd.createSignedToken('token', token);
const signedToken = w3rd.tokenFromJWT(wt, 'content');

w3rd.createTokenForAuth(token, { type: 'token' }, data);
w3rd.createUnsignedToken('token', signedToken);
const unsignedToken = w3rd.tokenFromJWT(wt, 'content');
```

### 8.
2025-06-14 22:27:04.317 [http-nio-8080-exec-10] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
java.lang.IllegalArgumentException: Not enough variable values available to expand ' type'
	at org.springframework.web.util.UriComponents$VarArgsTemplateVariables.getValue(UriComponents.java:370)
	at org.springframework.web.util.HierarchicalUriComponents$QueryUriTemplateVariables.getValue(HierarchicalUriComponents.java:1098)
	at org.springframework.web.util.UriComponents.expandUriComponent(UriComponents.java:263)
	at org.springframework.web.util.HierarchicalUriComponents.lambda$expandQueryParams$6(HierarchicalUriComponents.java:456)
	at org.springframework.util.UnmodifiableMultiValueMap.lambda$forEach$0(UnmodifiableMultiValueMap.java:115)
	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:986)
	at org.springframework.util.MultiValueMapAdapter.forEach(MultiValueMapAdapter.java:179)
	at org.springframework.util.UnmodifiableMultiValueMap.forEach(UnmodifiableMultiValueMap.java:115)
	at org.springframework.web.util.HierarchicalUriComponents.expandQueryParams(HierarchicalUriComponents.java:452)
	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:441)
	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:53)
	at org.springframework.web.util.UriComponents.expand(UriComponents.java:172)
	at org.springframework.web.util.DefaultUriBuilderFactory$DefaultUriBuilder.build(DefaultUriBuilderFactory.java:459)
	at pluto.upik.shared.translation.service.TranslationService.lambda$translate$0(TranslationService.java:75)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.uri(DefaultRestClient.java:336)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.uri(DefaultRestClient.java:287)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:71)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:27:04.318 [http-nio-8080-exec-10] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Update Web App with Token**
   - 最后，将你的Web 应用程序更新为使用了 JWT 标识。

```javascript
webApp.registerTokenJWT(wt, unsignedToken);
```

### 9. **Testing and Debugging**
   - 在实现过程中，可以进行一些测试和调试。比如查看 JWT 的结构是否正确，或者确保 API 端收到正确的 Token.

### 提示
- 建议你参考 Node.js Web API 的文档，以获得更好的理解。
- 如果需要更高级的功能，可能需要扩展你的项目。

通过以上步骤，你可以实现一个简单的 JWT 团队认证功能。记住，在实际应用中，安全和隐私是非常重要的，所以选择合适的密码和协议是必须的。
2025-06-14 22:27:04.627 [http-nio-8080-exec-10] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:27:58.100 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: How I can implemets JWT token in spring security?
2025-06-14 22:27:59.627 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 01 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 32 MINUTES 01 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateKoreanToEnglish(TranslationService.java:35)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:83)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:93)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:29:02.271 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: To implement JWT tokens in Spring Security, follow these organized steps:

### 1. Setup Token Management Service (TMS)
- **Import Necessary Classes**: Use `com.springframework.security.token.token_manager.TmsTokenManager` for token storage and expiration handling.
- **Create a TMS Instance**: Initialize a `TmsTokenManager` with the default storage implementation, which can be done by instantiating it without additional parameters.

### 2.
2025-06-14 22:29:03.286 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:29:03.293 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Implement Token Storage
- **Use Default Storage**: Create a new class that extends `com.springframework.web.xml.storage.DefaultStorage`. Define a method to handle token addition and update your application's database or store as needed.
- **Store Tokens Globally**: Use the default storage implementation to store tokens across the entire Spring Boot application, making it easy to manage.

### 3.
2025-06-14 22:29:03.606 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:29:03.610 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Validate and Refill Tokens
- **Token Validation**: Implement validation methods using `com.springframework.web.xmlVal verifier` to check each part of the token against the query string. Exceptions will be thrown if validation fails.
- **Refresh Tokens**: After successful authentication, use Spring Security's refilling method (if available) or manually update the stored token across your application.

### 4.
2025-06-14 22:29:03.915 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 57 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:29:03.917 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: Handling Expiration
- **Set Expired Period**: Define a period for each token storage in `Spring Data` to prevent tokens from staying indefinitely. Use this logic when updating the TMS instance.

### 5. Integration with API Calls
- **POST Requests**: Use Spring's RESTful API (e.g., Spring REST) or Spring Data REST APIs to send new tokens after authentication.
2025-06-14 22:29:04.330 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:29:04.334 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: - **Handling Client-side Exceptions**: Catch exceptions thrown by clients and let Spring Security handle any rethrown errors internally.

### 6. Custom Validation and Role-based Access
- **Validation Logic**: Implement custom validation methods within your API responses to ensure only authorized users receive valid tokens.
2025-06-14 22:29:04.737 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:29:04.739 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: - **Roles in Spring Security**: Define roles to manage access, allowing specific users or groups to have access to certain tokens.

### Example Workflow
1. **Set Up TMS**: Create a new class `TokenManager` and use the default storage.
2. **Add Token**: Use the `addToken` method from the TMS instance upon user authentication.
3. **Validate and Refresh**: Ensure token validation on each API call and refill after successful authentication.
2025-06-14 22:29:05.149 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 56 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:29:05.153 [http-nio-8080-exec-4] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: ### Testing
- **Testing Validations**: Verify that invalid tokens throw exceptions when they try to be validated.
- **Review Tokens**: Check if Spring Security handles partial tokens correctly and refreshes them appropriately.

By following these steps, you can effectively integrate JWT tokens into your Spring Security application, ensuring secure and efficient token handling.
2025-06-14 22:29:05.475 [http-nio-8080-exec-4] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 55 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 30 MINUTES 55 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.resolver.AIController.askQuestion(AIController.java:31)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:32:57.254 [http-nio-8080-exec-8] DEBUG p.u.s.t.service.TranslationService - 한국어를 영어로 번역: Please generate a guide title for the following vote. The title should be concise and clear.

Vote Title: how i can go school?
Vote Description: school is so good

Guide Title:
2025-06-14 22:32:58.446 [http-nio-8080-exec-8] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 27 MINUTES 02 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 27 MINUTES 02 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateKoreanToEnglish(TranslationService.java:35)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:83)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:93)
	at pluto.upik.shared.ai.service.AIService.generateGuideTitle(AIService.java:138)
	at pluto.upik.shared.ai.resolver.AIController.generateGuideTitle(AIController.java:44)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:33:11.463 [http-nio-8080-exec-8] DEBUG p.u.s.t.service.TranslationService - 영어를 한국어로 번역: **Title:** Can You Go School?
2025-06-14 22:33:11.832 [http-nio-8080-exec-8] ERROR p.u.s.t.service.TranslationService - 번역 API 호출 중 오류 발생
org.springframework.web.client.HttpClientErrorException$TooManyRequests: 429 Too Many Requests: "{"responseData":{"translatedText":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 26 MINUTES 49 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE"},"quotaFinished":null,"mtLangSupported":null,"responseDetails":"MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  19 HOURS 26 MINUTES 49 SECONDS VISIT HTTPS:\/\/MYMEMORY.TRANSLATED.NET\/DOC\/USAGELIMITS.PHP TO TRANSLATE MORE","responseStatus":429,"responderId":null,"exception_code":null,"matches":""}"
	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:130)
	at org.springframework.web.client.StatusHandler.lambda$defaultHandler$3(StatusHandler.java:86)
	at org.springframework.web.client.StatusHandler.handle(StatusHandler.java:146)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.applyStatusHandlers(DefaultRestClient.java:831)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$readBody$4(DefaultRestClient.java:820)
	at org.springframework.web.client.DefaultRestClient.readWithMessageConverters(DefaultRestClient.java:216)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.readBody(DefaultRestClient.java:819)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.lambda$body$0(DefaultRestClient.java:750)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchangeInternal(DefaultRestClient.java:579)
	at org.springframework.web.client.DefaultRestClient$DefaultRequestBodyUriSpec.exchange(DefaultRestClient.java:533)
	at org.springframework.web.client.RestClient$RequestHeadersSpec.exchange(RestClient.java:680)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.executeAndExtract(DefaultRestClient.java:814)
	at org.springframework.web.client.DefaultRestClient$DefaultResponseSpec.body(DefaultRestClient.java:750)
	at pluto.upik.shared.translation.service.TranslationService.translate(TranslationService.java:77)
	at pluto.upik.shared.translation.service.TranslationService.translateEnglishToKorean(TranslationService.java:52)
	at pluto.upik.shared.ai.service.AIService.translateLongText(AIService.java:84)
	at pluto.upik.shared.ai.service.AIService.askToDeepSeekAI(AIService.java:114)
	at pluto.upik.shared.ai.service.AIService.generateGuideTitle(AIService.java:138)
	at pluto.upik.shared.ai.resolver.AIController.generateGuideTitle(AIController.java:44)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:125)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216)
	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:202)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:235)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:229)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter.doFilterInternal(OAuth2AuthorizationRequestRedirectFilter.java:198)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.ServletRequestPathFilter.doFilter(ServletRequestPathFilter.java:52)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebSecurityConfiguration.java:319)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:240)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)
	at java.base/java.lang.Thread.run(Thread.java:1583)
2025-06-14 22:34:29.511 [HikariPool-1:housekeeper] WARN  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Thread starvation or clock leap detected (housekeeper delta=52s71ms).
2025-06-14 22:34:38.851 [SpringApplicationShutdownHook] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Commencing graceful shutdown. Waiting for active requests to complete
2025-06-14 22:34:38.909 [tomcat-shutdown] INFO  o.s.b.w.e.tomcat.GracefulShutdown - Graceful shutdown complete
2025-06-14 22:34:38.965 [SpringApplicationShutdownHook] INFO  o.s.o.j.LocalContainerEntityManagerFactoryBean - Closing JPA EntityManagerFactory for persistence unit 'default'
2025-06-14 22:34:39.014 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown initiated...
2025-06-14 22:34:39.073 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown completed.
